// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cartographer/cloud/proto/map_builder_service.proto

#ifndef PROTOBUF_INCLUDED_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto
#define PROTOBUF_INCLUDED_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "cartographer/mapping/proto/pose_graph.pb.h"
#include "cartographer/mapping/proto/serialization.pb.h"
#include "cartographer/mapping/proto/submap_visualization.pb.h"
#include "cartographer/mapping/proto/trajectory_builder_options.pb.h"
#include "cartographer/sensor/proto/sensor.pb.h"
#include "cartographer/transform/proto/transform.pb.h"
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto 

namespace protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[46];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto
namespace cartographer {
namespace cloud {
namespace proto {
class AddFixedFramePoseDataRequest;
class AddFixedFramePoseDataRequestDefaultTypeInternal;
extern AddFixedFramePoseDataRequestDefaultTypeInternal _AddFixedFramePoseDataRequest_default_instance_;
class AddImuDataRequest;
class AddImuDataRequestDefaultTypeInternal;
extern AddImuDataRequestDefaultTypeInternal _AddImuDataRequest_default_instance_;
class AddLandmarkDataRequest;
class AddLandmarkDataRequestDefaultTypeInternal;
extern AddLandmarkDataRequestDefaultTypeInternal _AddLandmarkDataRequest_default_instance_;
class AddOdometryDataRequest;
class AddOdometryDataRequestDefaultTypeInternal;
extern AddOdometryDataRequestDefaultTypeInternal _AddOdometryDataRequest_default_instance_;
class AddRangefinderDataRequest;
class AddRangefinderDataRequestDefaultTypeInternal;
extern AddRangefinderDataRequestDefaultTypeInternal _AddRangefinderDataRequest_default_instance_;
class AddSensorDataBatchRequest;
class AddSensorDataBatchRequestDefaultTypeInternal;
extern AddSensorDataBatchRequestDefaultTypeInternal _AddSensorDataBatchRequest_default_instance_;
class AddTrajectoryRequest;
class AddTrajectoryRequestDefaultTypeInternal;
extern AddTrajectoryRequestDefaultTypeInternal _AddTrajectoryRequest_default_instance_;
class AddTrajectoryResponse;
class AddTrajectoryResponseDefaultTypeInternal;
extern AddTrajectoryResponseDefaultTypeInternal _AddTrajectoryResponse_default_instance_;
class DeleteTrajectoryRequest;
class DeleteTrajectoryRequestDefaultTypeInternal;
extern DeleteTrajectoryRequestDefaultTypeInternal _DeleteTrajectoryRequest_default_instance_;
class FinishTrajectoryRequest;
class FinishTrajectoryRequestDefaultTypeInternal;
extern FinishTrajectoryRequestDefaultTypeInternal _FinishTrajectoryRequest_default_instance_;
class GetAllSubmapPosesResponse;
class GetAllSubmapPosesResponseDefaultTypeInternal;
extern GetAllSubmapPosesResponseDefaultTypeInternal _GetAllSubmapPosesResponse_default_instance_;
class GetConstraintsResponse;
class GetConstraintsResponseDefaultTypeInternal;
extern GetConstraintsResponseDefaultTypeInternal _GetConstraintsResponse_default_instance_;
class GetLandmarkPosesResponse;
class GetLandmarkPosesResponseDefaultTypeInternal;
extern GetLandmarkPosesResponseDefaultTypeInternal _GetLandmarkPosesResponse_default_instance_;
class GetLocalToGlobalTransformRequest;
class GetLocalToGlobalTransformRequestDefaultTypeInternal;
extern GetLocalToGlobalTransformRequestDefaultTypeInternal _GetLocalToGlobalTransformRequest_default_instance_;
class GetLocalToGlobalTransformResponse;
class GetLocalToGlobalTransformResponseDefaultTypeInternal;
extern GetLocalToGlobalTransformResponseDefaultTypeInternal _GetLocalToGlobalTransformResponse_default_instance_;
class GetSubmapRequest;
class GetSubmapRequestDefaultTypeInternal;
extern GetSubmapRequestDefaultTypeInternal _GetSubmapRequest_default_instance_;
class GetSubmapResponse;
class GetSubmapResponseDefaultTypeInternal;
extern GetSubmapResponseDefaultTypeInternal _GetSubmapResponse_default_instance_;
class GetTrajectoryNodePosesResponse;
class GetTrajectoryNodePosesResponseDefaultTypeInternal;
extern GetTrajectoryNodePosesResponseDefaultTypeInternal _GetTrajectoryNodePosesResponse_default_instance_;
class GetTrajectoryStatesResponse;
class GetTrajectoryStatesResponseDefaultTypeInternal;
extern GetTrajectoryStatesResponseDefaultTypeInternal _GetTrajectoryStatesResponse_default_instance_;
class GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse;
class GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUseDefaultTypeInternal;
extern GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUseDefaultTypeInternal _GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse_default_instance_;
class IsTrajectoryFinishedRequest;
class IsTrajectoryFinishedRequestDefaultTypeInternal;
extern IsTrajectoryFinishedRequestDefaultTypeInternal _IsTrajectoryFinishedRequest_default_instance_;
class IsTrajectoryFinishedResponse;
class IsTrajectoryFinishedResponseDefaultTypeInternal;
extern IsTrajectoryFinishedResponseDefaultTypeInternal _IsTrajectoryFinishedResponse_default_instance_;
class IsTrajectoryFrozenRequest;
class IsTrajectoryFrozenRequestDefaultTypeInternal;
extern IsTrajectoryFrozenRequestDefaultTypeInternal _IsTrajectoryFrozenRequest_default_instance_;
class IsTrajectoryFrozenResponse;
class IsTrajectoryFrozenResponseDefaultTypeInternal;
extern IsTrajectoryFrozenResponseDefaultTypeInternal _IsTrajectoryFrozenResponse_default_instance_;
class LoadStateFromFileRequest;
class LoadStateFromFileRequestDefaultTypeInternal;
extern LoadStateFromFileRequestDefaultTypeInternal _LoadStateFromFileRequest_default_instance_;
class LoadStateFromFileResponse;
class LoadStateFromFileResponseDefaultTypeInternal;
extern LoadStateFromFileResponseDefaultTypeInternal _LoadStateFromFileResponse_default_instance_;
class LoadStateRequest;
class LoadStateRequestDefaultTypeInternal;
extern LoadStateRequestDefaultTypeInternal _LoadStateRequest_default_instance_;
class LoadStateResponse;
class LoadStateResponseDefaultTypeInternal;
extern LoadStateResponseDefaultTypeInternal _LoadStateResponse_default_instance_;
class LocalSlamInsertionResult;
class LocalSlamInsertionResultDefaultTypeInternal;
extern LocalSlamInsertionResultDefaultTypeInternal _LocalSlamInsertionResult_default_instance_;
class ReceiveGlobalSlamOptimizationsResponse;
class ReceiveGlobalSlamOptimizationsResponseDefaultTypeInternal;
extern ReceiveGlobalSlamOptimizationsResponseDefaultTypeInternal _ReceiveGlobalSlamOptimizationsResponse_default_instance_;
class ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse;
class ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUseDefaultTypeInternal;
extern ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUseDefaultTypeInternal _ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse_default_instance_;
class ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse;
class ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUseDefaultTypeInternal;
extern ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUseDefaultTypeInternal _ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse_default_instance_;
class ReceiveLocalSlamResultsRequest;
class ReceiveLocalSlamResultsRequestDefaultTypeInternal;
extern ReceiveLocalSlamResultsRequestDefaultTypeInternal _ReceiveLocalSlamResultsRequest_default_instance_;
class ReceiveLocalSlamResultsResponse;
class ReceiveLocalSlamResultsResponseDefaultTypeInternal;
extern ReceiveLocalSlamResultsResponseDefaultTypeInternal _ReceiveLocalSlamResultsResponse_default_instance_;
class SensorData;
class SensorDataDefaultTypeInternal;
extern SensorDataDefaultTypeInternal _SensorData_default_instance_;
class SensorId;
class SensorIdDefaultTypeInternal;
extern SensorIdDefaultTypeInternal _SensorId_default_instance_;
class SensorMetadata;
class SensorMetadataDefaultTypeInternal;
extern SensorMetadataDefaultTypeInternal _SensorMetadata_default_instance_;
class SetLandmarkPoseRequest;
class SetLandmarkPoseRequestDefaultTypeInternal;
extern SetLandmarkPoseRequestDefaultTypeInternal _SetLandmarkPoseRequest_default_instance_;
class SubmapPose;
class SubmapPoseDefaultTypeInternal;
extern SubmapPoseDefaultTypeInternal _SubmapPose_default_instance_;
class TrajectoryNodePose;
class TrajectoryNodePoseDefaultTypeInternal;
extern TrajectoryNodePoseDefaultTypeInternal _TrajectoryNodePose_default_instance_;
class TrajectoryNodePose_ConstantPoseData;
class TrajectoryNodePose_ConstantPoseDataDefaultTypeInternal;
extern TrajectoryNodePose_ConstantPoseDataDefaultTypeInternal _TrajectoryNodePose_ConstantPoseData_default_instance_;
class TrajectoryRemapping;
class TrajectoryRemappingDefaultTypeInternal;
extern TrajectoryRemappingDefaultTypeInternal _TrajectoryRemapping_default_instance_;
class TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse;
class TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUseDefaultTypeInternal;
extern TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUseDefaultTypeInternal _TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse_default_instance_;
class WriteStateResponse;
class WriteStateResponseDefaultTypeInternal;
extern WriteStateResponseDefaultTypeInternal _WriteStateResponse_default_instance_;
class WriteStateToFileRequest;
class WriteStateToFileRequestDefaultTypeInternal;
extern WriteStateToFileRequestDefaultTypeInternal _WriteStateToFileRequest_default_instance_;
class WriteStateToFileResponse;
class WriteStateToFileResponseDefaultTypeInternal;
extern WriteStateToFileResponseDefaultTypeInternal _WriteStateToFileResponse_default_instance_;
}  // namespace proto
}  // namespace cloud
}  // namespace cartographer
namespace google {
namespace protobuf {
template<> ::cartographer::cloud::proto::AddFixedFramePoseDataRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::AddFixedFramePoseDataRequest>(Arena*);
template<> ::cartographer::cloud::proto::AddImuDataRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::AddImuDataRequest>(Arena*);
template<> ::cartographer::cloud::proto::AddLandmarkDataRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::AddLandmarkDataRequest>(Arena*);
template<> ::cartographer::cloud::proto::AddOdometryDataRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::AddOdometryDataRequest>(Arena*);
template<> ::cartographer::cloud::proto::AddRangefinderDataRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::AddRangefinderDataRequest>(Arena*);
template<> ::cartographer::cloud::proto::AddSensorDataBatchRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::AddSensorDataBatchRequest>(Arena*);
template<> ::cartographer::cloud::proto::AddTrajectoryRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::AddTrajectoryRequest>(Arena*);
template<> ::cartographer::cloud::proto::AddTrajectoryResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::AddTrajectoryResponse>(Arena*);
template<> ::cartographer::cloud::proto::DeleteTrajectoryRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::DeleteTrajectoryRequest>(Arena*);
template<> ::cartographer::cloud::proto::FinishTrajectoryRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::FinishTrajectoryRequest>(Arena*);
template<> ::cartographer::cloud::proto::GetAllSubmapPosesResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::GetAllSubmapPosesResponse>(Arena*);
template<> ::cartographer::cloud::proto::GetConstraintsResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::GetConstraintsResponse>(Arena*);
template<> ::cartographer::cloud::proto::GetLandmarkPosesResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::GetLandmarkPosesResponse>(Arena*);
template<> ::cartographer::cloud::proto::GetLocalToGlobalTransformRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::GetLocalToGlobalTransformRequest>(Arena*);
template<> ::cartographer::cloud::proto::GetLocalToGlobalTransformResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::GetLocalToGlobalTransformResponse>(Arena*);
template<> ::cartographer::cloud::proto::GetSubmapRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::GetSubmapRequest>(Arena*);
template<> ::cartographer::cloud::proto::GetSubmapResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::GetSubmapResponse>(Arena*);
template<> ::cartographer::cloud::proto::GetTrajectoryNodePosesResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::GetTrajectoryNodePosesResponse>(Arena*);
template<> ::cartographer::cloud::proto::GetTrajectoryStatesResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::GetTrajectoryStatesResponse>(Arena*);
template<> ::cartographer::cloud::proto::GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse>(Arena*);
template<> ::cartographer::cloud::proto::IsTrajectoryFinishedRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::IsTrajectoryFinishedRequest>(Arena*);
template<> ::cartographer::cloud::proto::IsTrajectoryFinishedResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::IsTrajectoryFinishedResponse>(Arena*);
template<> ::cartographer::cloud::proto::IsTrajectoryFrozenRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::IsTrajectoryFrozenRequest>(Arena*);
template<> ::cartographer::cloud::proto::IsTrajectoryFrozenResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::IsTrajectoryFrozenResponse>(Arena*);
template<> ::cartographer::cloud::proto::LoadStateFromFileRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::LoadStateFromFileRequest>(Arena*);
template<> ::cartographer::cloud::proto::LoadStateFromFileResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::LoadStateFromFileResponse>(Arena*);
template<> ::cartographer::cloud::proto::LoadStateRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::LoadStateRequest>(Arena*);
template<> ::cartographer::cloud::proto::LoadStateResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::LoadStateResponse>(Arena*);
template<> ::cartographer::cloud::proto::LocalSlamInsertionResult* Arena::CreateMaybeMessage<::cartographer::cloud::proto::LocalSlamInsertionResult>(Arena*);
template<> ::cartographer::cloud::proto::ReceiveGlobalSlamOptimizationsResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::ReceiveGlobalSlamOptimizationsResponse>(Arena*);
template<> ::cartographer::cloud::proto::ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse>(Arena*);
template<> ::cartographer::cloud::proto::ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse>(Arena*);
template<> ::cartographer::cloud::proto::ReceiveLocalSlamResultsRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::ReceiveLocalSlamResultsRequest>(Arena*);
template<> ::cartographer::cloud::proto::ReceiveLocalSlamResultsResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::ReceiveLocalSlamResultsResponse>(Arena*);
template<> ::cartographer::cloud::proto::SensorData* Arena::CreateMaybeMessage<::cartographer::cloud::proto::SensorData>(Arena*);
template<> ::cartographer::cloud::proto::SensorId* Arena::CreateMaybeMessage<::cartographer::cloud::proto::SensorId>(Arena*);
template<> ::cartographer::cloud::proto::SensorMetadata* Arena::CreateMaybeMessage<::cartographer::cloud::proto::SensorMetadata>(Arena*);
template<> ::cartographer::cloud::proto::SetLandmarkPoseRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::SetLandmarkPoseRequest>(Arena*);
template<> ::cartographer::cloud::proto::SubmapPose* Arena::CreateMaybeMessage<::cartographer::cloud::proto::SubmapPose>(Arena*);
template<> ::cartographer::cloud::proto::TrajectoryNodePose* Arena::CreateMaybeMessage<::cartographer::cloud::proto::TrajectoryNodePose>(Arena*);
template<> ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData* Arena::CreateMaybeMessage<::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData>(Arena*);
template<> ::cartographer::cloud::proto::TrajectoryRemapping* Arena::CreateMaybeMessage<::cartographer::cloud::proto::TrajectoryRemapping>(Arena*);
template<> ::cartographer::cloud::proto::TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse>(Arena*);
template<> ::cartographer::cloud::proto::WriteStateResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::WriteStateResponse>(Arena*);
template<> ::cartographer::cloud::proto::WriteStateToFileRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::WriteStateToFileRequest>(Arena*);
template<> ::cartographer::cloud::proto::WriteStateToFileResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::WriteStateToFileResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace cartographer {
namespace cloud {
namespace proto {

enum SensorType {
  RANGE = 0,
  IMU = 1,
  ODOMETRY = 2,
  FIXED_FRAME_POSE = 3,
  LANDMARK = 4,
  LOCAL_SLAM_RESULT = 5,
  SensorType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SensorType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SensorType_IsValid(int value);
const SensorType SensorType_MIN = RANGE;
const SensorType SensorType_MAX = LOCAL_SLAM_RESULT;
const int SensorType_ARRAYSIZE = SensorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SensorType_descriptor();
inline const ::std::string& SensorType_Name(SensorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SensorType_descriptor(), value);
}
inline bool SensorType_Parse(
    const ::std::string& name, SensorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SensorType>(
    SensorType_descriptor(), name, value);
}
enum TrajectoryState {
  ACTIVE = 0,
  FINISHED = 1,
  FROZEN = 2,
  DELETED = 3,
  TrajectoryState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrajectoryState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrajectoryState_IsValid(int value);
const TrajectoryState TrajectoryState_MIN = ACTIVE;
const TrajectoryState TrajectoryState_MAX = DELETED;
const int TrajectoryState_ARRAYSIZE = TrajectoryState_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrajectoryState_descriptor();
inline const ::std::string& TrajectoryState_Name(TrajectoryState value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrajectoryState_descriptor(), value);
}
inline bool TrajectoryState_Parse(
    const ::std::string& name, TrajectoryState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrajectoryState>(
    TrajectoryState_descriptor(), name, value);
}
// ===================================================================

class SensorId : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.SensorId) */ {
 public:
  SensorId();
  virtual ~SensorId();

  SensorId(const SensorId& from);

  inline SensorId& operator=(const SensorId& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SensorId(SensorId&& from) noexcept
    : SensorId() {
    *this = ::std::move(from);
  }

  inline SensorId& operator=(SensorId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorId* internal_default_instance() {
    return reinterpret_cast<const SensorId*>(
               &_SensorId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(SensorId* other);
  friend void swap(SensorId& a, SensorId& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorId* New() const final {
    return CreateMaybeMessage<SensorId>(NULL);
  }

  SensorId* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SensorId>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SensorId& from);
  void MergeFrom(const SensorId& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorId* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // .cartographer.cloud.proto.SensorType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::cartographer::cloud::proto::SensorType type() const;
  void set_type(::cartographer::cloud::proto::SensorType value);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.SensorId)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddTrajectoryRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.AddTrajectoryRequest) */ {
 public:
  AddTrajectoryRequest();
  virtual ~AddTrajectoryRequest();

  AddTrajectoryRequest(const AddTrajectoryRequest& from);

  inline AddTrajectoryRequest& operator=(const AddTrajectoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddTrajectoryRequest(AddTrajectoryRequest&& from) noexcept
    : AddTrajectoryRequest() {
    *this = ::std::move(from);
  }

  inline AddTrajectoryRequest& operator=(AddTrajectoryRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddTrajectoryRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddTrajectoryRequest* internal_default_instance() {
    return reinterpret_cast<const AddTrajectoryRequest*>(
               &_AddTrajectoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(AddTrajectoryRequest* other);
  friend void swap(AddTrajectoryRequest& a, AddTrajectoryRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddTrajectoryRequest* New() const final {
    return CreateMaybeMessage<AddTrajectoryRequest>(NULL);
  }

  AddTrajectoryRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddTrajectoryRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddTrajectoryRequest& from);
  void MergeFrom(const AddTrajectoryRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddTrajectoryRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .cartographer.cloud.proto.SensorId expected_sensor_ids = 3;
  int expected_sensor_ids_size() const;
  void clear_expected_sensor_ids();
  static const int kExpectedSensorIdsFieldNumber = 3;
  ::cartographer::cloud::proto::SensorId* mutable_expected_sensor_ids(int index);
  ::google::protobuf::RepeatedPtrField< ::cartographer::cloud::proto::SensorId >*
      mutable_expected_sensor_ids();
  const ::cartographer::cloud::proto::SensorId& expected_sensor_ids(int index) const;
  ::cartographer::cloud::proto::SensorId* add_expected_sensor_ids();
  const ::google::protobuf::RepeatedPtrField< ::cartographer::cloud::proto::SensorId >&
      expected_sensor_ids() const;

  // string client_id = 4;
  void clear_client_id();
  static const int kClientIdFieldNumber = 4;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  #if LANG_CXX11
  void set_client_id(::std::string&& value);
  #endif
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  // .cartographer.mapping.proto.TrajectoryBuilderOptions trajectory_builder_options = 2;
  bool has_trajectory_builder_options() const;
  void clear_trajectory_builder_options();
  static const int kTrajectoryBuilderOptionsFieldNumber = 2;
  private:
  const ::cartographer::mapping::proto::TrajectoryBuilderOptions& _internal_trajectory_builder_options() const;
  public:
  const ::cartographer::mapping::proto::TrajectoryBuilderOptions& trajectory_builder_options() const;
  ::cartographer::mapping::proto::TrajectoryBuilderOptions* release_trajectory_builder_options();
  ::cartographer::mapping::proto::TrajectoryBuilderOptions* mutable_trajectory_builder_options();
  void set_allocated_trajectory_builder_options(::cartographer::mapping::proto::TrajectoryBuilderOptions* trajectory_builder_options);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.AddTrajectoryRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::cartographer::cloud::proto::SensorId > expected_sensor_ids_;
  ::google::protobuf::internal::ArenaStringPtr client_id_;
  ::cartographer::mapping::proto::TrajectoryBuilderOptions* trajectory_builder_options_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SensorMetadata : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.SensorMetadata) */ {
 public:
  SensorMetadata();
  virtual ~SensorMetadata();

  SensorMetadata(const SensorMetadata& from);

  inline SensorMetadata& operator=(const SensorMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SensorMetadata(SensorMetadata&& from) noexcept
    : SensorMetadata() {
    *this = ::std::move(from);
  }

  inline SensorMetadata& operator=(SensorMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorMetadata* internal_default_instance() {
    return reinterpret_cast<const SensorMetadata*>(
               &_SensorMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(SensorMetadata* other);
  friend void swap(SensorMetadata& a, SensorMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorMetadata* New() const final {
    return CreateMaybeMessage<SensorMetadata>(NULL);
  }

  SensorMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SensorMetadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SensorMetadata& from);
  void MergeFrom(const SensorMetadata& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sensor_id = 2;
  void clear_sensor_id();
  static const int kSensorIdFieldNumber = 2;
  const ::std::string& sensor_id() const;
  void set_sensor_id(const ::std::string& value);
  #if LANG_CXX11
  void set_sensor_id(::std::string&& value);
  #endif
  void set_sensor_id(const char* value);
  void set_sensor_id(const char* value, size_t size);
  ::std::string* mutable_sensor_id();
  ::std::string* release_sensor_id();
  void set_allocated_sensor_id(::std::string* sensor_id);

  // string client_id = 3;
  void clear_client_id();
  static const int kClientIdFieldNumber = 3;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  #if LANG_CXX11
  void set_client_id(::std::string&& value);
  #endif
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  // int32 trajectory_id = 1;
  void clear_trajectory_id();
  static const int kTrajectoryIdFieldNumber = 1;
  ::google::protobuf::int32 trajectory_id() const;
  void set_trajectory_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.SensorMetadata)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sensor_id_;
  ::google::protobuf::internal::ArenaStringPtr client_id_;
  ::google::protobuf::int32 trajectory_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SensorData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.SensorData) */ {
 public:
  SensorData();
  virtual ~SensorData();

  SensorData(const SensorData& from);

  inline SensorData& operator=(const SensorData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SensorData(SensorData&& from) noexcept
    : SensorData() {
    *this = ::std::move(from);
  }

  inline SensorData& operator=(SensorData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorData& default_instance();

  enum SensorDataCase {
    kOdometryData = 2,
    kImuData = 3,
    kTimedPointCloudData = 4,
    kFixedFramePoseData = 5,
    kLandmarkData = 6,
    kLocalSlamResultData = 7,
    SENSOR_DATA_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorData* internal_default_instance() {
    return reinterpret_cast<const SensorData*>(
               &_SensorData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(SensorData* other);
  friend void swap(SensorData& a, SensorData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorData* New() const final {
    return CreateMaybeMessage<SensorData>(NULL);
  }

  SensorData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SensorData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SensorData& from);
  void MergeFrom(const SensorData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cartographer.cloud.proto.SensorMetadata sensor_metadata = 1;
  bool has_sensor_metadata() const;
  void clear_sensor_metadata();
  static const int kSensorMetadataFieldNumber = 1;
  private:
  const ::cartographer::cloud::proto::SensorMetadata& _internal_sensor_metadata() const;
  public:
  const ::cartographer::cloud::proto::SensorMetadata& sensor_metadata() const;
  ::cartographer::cloud::proto::SensorMetadata* release_sensor_metadata();
  ::cartographer::cloud::proto::SensorMetadata* mutable_sensor_metadata();
  void set_allocated_sensor_metadata(::cartographer::cloud::proto::SensorMetadata* sensor_metadata);

  // .cartographer.sensor.proto.OdometryData odometry_data = 2;
  bool has_odometry_data() const;
  void clear_odometry_data();
  static const int kOdometryDataFieldNumber = 2;
  private:
  const ::cartographer::sensor::proto::OdometryData& _internal_odometry_data() const;
  public:
  const ::cartographer::sensor::proto::OdometryData& odometry_data() const;
  ::cartographer::sensor::proto::OdometryData* release_odometry_data();
  ::cartographer::sensor::proto::OdometryData* mutable_odometry_data();
  void set_allocated_odometry_data(::cartographer::sensor::proto::OdometryData* odometry_data);

  // .cartographer.sensor.proto.ImuData imu_data = 3;
  bool has_imu_data() const;
  void clear_imu_data();
  static const int kImuDataFieldNumber = 3;
  private:
  const ::cartographer::sensor::proto::ImuData& _internal_imu_data() const;
  public:
  const ::cartographer::sensor::proto::ImuData& imu_data() const;
  ::cartographer::sensor::proto::ImuData* release_imu_data();
  ::cartographer::sensor::proto::ImuData* mutable_imu_data();
  void set_allocated_imu_data(::cartographer::sensor::proto::ImuData* imu_data);

  // .cartographer.sensor.proto.TimedPointCloudData timed_point_cloud_data = 4;
  bool has_timed_point_cloud_data() const;
  void clear_timed_point_cloud_data();
  static const int kTimedPointCloudDataFieldNumber = 4;
  private:
  const ::cartographer::sensor::proto::TimedPointCloudData& _internal_timed_point_cloud_data() const;
  public:
  const ::cartographer::sensor::proto::TimedPointCloudData& timed_point_cloud_data() const;
  ::cartographer::sensor::proto::TimedPointCloudData* release_timed_point_cloud_data();
  ::cartographer::sensor::proto::TimedPointCloudData* mutable_timed_point_cloud_data();
  void set_allocated_timed_point_cloud_data(::cartographer::sensor::proto::TimedPointCloudData* timed_point_cloud_data);

  // .cartographer.sensor.proto.FixedFramePoseData fixed_frame_pose_data = 5;
  bool has_fixed_frame_pose_data() const;
  void clear_fixed_frame_pose_data();
  static const int kFixedFramePoseDataFieldNumber = 5;
  private:
  const ::cartographer::sensor::proto::FixedFramePoseData& _internal_fixed_frame_pose_data() const;
  public:
  const ::cartographer::sensor::proto::FixedFramePoseData& fixed_frame_pose_data() const;
  ::cartographer::sensor::proto::FixedFramePoseData* release_fixed_frame_pose_data();
  ::cartographer::sensor::proto::FixedFramePoseData* mutable_fixed_frame_pose_data();
  void set_allocated_fixed_frame_pose_data(::cartographer::sensor::proto::FixedFramePoseData* fixed_frame_pose_data);

  // .cartographer.sensor.proto.LandmarkData landmark_data = 6;
  bool has_landmark_data() const;
  void clear_landmark_data();
  static const int kLandmarkDataFieldNumber = 6;
  private:
  const ::cartographer::sensor::proto::LandmarkData& _internal_landmark_data() const;
  public:
  const ::cartographer::sensor::proto::LandmarkData& landmark_data() const;
  ::cartographer::sensor::proto::LandmarkData* release_landmark_data();
  ::cartographer::sensor::proto::LandmarkData* mutable_landmark_data();
  void set_allocated_landmark_data(::cartographer::sensor::proto::LandmarkData* landmark_data);

  // .cartographer.mapping.proto.LocalSlamResultData local_slam_result_data = 7;
  bool has_local_slam_result_data() const;
  void clear_local_slam_result_data();
  static const int kLocalSlamResultDataFieldNumber = 7;
  private:
  const ::cartographer::mapping::proto::LocalSlamResultData& _internal_local_slam_result_data() const;
  public:
  const ::cartographer::mapping::proto::LocalSlamResultData& local_slam_result_data() const;
  ::cartographer::mapping::proto::LocalSlamResultData* release_local_slam_result_data();
  ::cartographer::mapping::proto::LocalSlamResultData* mutable_local_slam_result_data();
  void set_allocated_local_slam_result_data(::cartographer::mapping::proto::LocalSlamResultData* local_slam_result_data);

  void clear_sensor_data();
  SensorDataCase sensor_data_case() const;
  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.SensorData)
 private:
  void set_has_odometry_data();
  void set_has_imu_data();
  void set_has_timed_point_cloud_data();
  void set_has_fixed_frame_pose_data();
  void set_has_landmark_data();
  void set_has_local_slam_result_data();

  inline bool has_sensor_data() const;
  inline void clear_has_sensor_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::cloud::proto::SensorMetadata* sensor_metadata_;
  union SensorDataUnion {
    SensorDataUnion() {}
    ::cartographer::sensor::proto::OdometryData* odometry_data_;
    ::cartographer::sensor::proto::ImuData* imu_data_;
    ::cartographer::sensor::proto::TimedPointCloudData* timed_point_cloud_data_;
    ::cartographer::sensor::proto::FixedFramePoseData* fixed_frame_pose_data_;
    ::cartographer::sensor::proto::LandmarkData* landmark_data_;
    ::cartographer::mapping::proto::LocalSlamResultData* local_slam_result_data_;
  } sensor_data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddTrajectoryResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.AddTrajectoryResponse) */ {
 public:
  AddTrajectoryResponse();
  virtual ~AddTrajectoryResponse();

  AddTrajectoryResponse(const AddTrajectoryResponse& from);

  inline AddTrajectoryResponse& operator=(const AddTrajectoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddTrajectoryResponse(AddTrajectoryResponse&& from) noexcept
    : AddTrajectoryResponse() {
    *this = ::std::move(from);
  }

  inline AddTrajectoryResponse& operator=(AddTrajectoryResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddTrajectoryResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddTrajectoryResponse* internal_default_instance() {
    return reinterpret_cast<const AddTrajectoryResponse*>(
               &_AddTrajectoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(AddTrajectoryResponse* other);
  friend void swap(AddTrajectoryResponse& a, AddTrajectoryResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddTrajectoryResponse* New() const final {
    return CreateMaybeMessage<AddTrajectoryResponse>(NULL);
  }

  AddTrajectoryResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddTrajectoryResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddTrajectoryResponse& from);
  void MergeFrom(const AddTrajectoryResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddTrajectoryResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 trajectory_id = 1;
  void clear_trajectory_id();
  static const int kTrajectoryIdFieldNumber = 1;
  ::google::protobuf::int32 trajectory_id() const;
  void set_trajectory_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.AddTrajectoryResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 trajectory_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddSensorDataBatchRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.AddSensorDataBatchRequest) */ {
 public:
  AddSensorDataBatchRequest();
  virtual ~AddSensorDataBatchRequest();

  AddSensorDataBatchRequest(const AddSensorDataBatchRequest& from);

  inline AddSensorDataBatchRequest& operator=(const AddSensorDataBatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddSensorDataBatchRequest(AddSensorDataBatchRequest&& from) noexcept
    : AddSensorDataBatchRequest() {
    *this = ::std::move(from);
  }

  inline AddSensorDataBatchRequest& operator=(AddSensorDataBatchRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddSensorDataBatchRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddSensorDataBatchRequest* internal_default_instance() {
    return reinterpret_cast<const AddSensorDataBatchRequest*>(
               &_AddSensorDataBatchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(AddSensorDataBatchRequest* other);
  friend void swap(AddSensorDataBatchRequest& a, AddSensorDataBatchRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddSensorDataBatchRequest* New() const final {
    return CreateMaybeMessage<AddSensorDataBatchRequest>(NULL);
  }

  AddSensorDataBatchRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddSensorDataBatchRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddSensorDataBatchRequest& from);
  void MergeFrom(const AddSensorDataBatchRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddSensorDataBatchRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .cartographer.cloud.proto.SensorData sensor_data = 1;
  int sensor_data_size() const;
  void clear_sensor_data();
  static const int kSensorDataFieldNumber = 1;
  ::cartographer::cloud::proto::SensorData* mutable_sensor_data(int index);
  ::google::protobuf::RepeatedPtrField< ::cartographer::cloud::proto::SensorData >*
      mutable_sensor_data();
  const ::cartographer::cloud::proto::SensorData& sensor_data(int index) const;
  ::cartographer::cloud::proto::SensorData* add_sensor_data();
  const ::google::protobuf::RepeatedPtrField< ::cartographer::cloud::proto::SensorData >&
      sensor_data() const;

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.AddSensorDataBatchRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::cartographer::cloud::proto::SensorData > sensor_data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddOdometryDataRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.AddOdometryDataRequest) */ {
 public:
  AddOdometryDataRequest();
  virtual ~AddOdometryDataRequest();

  AddOdometryDataRequest(const AddOdometryDataRequest& from);

  inline AddOdometryDataRequest& operator=(const AddOdometryDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddOdometryDataRequest(AddOdometryDataRequest&& from) noexcept
    : AddOdometryDataRequest() {
    *this = ::std::move(from);
  }

  inline AddOdometryDataRequest& operator=(AddOdometryDataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddOdometryDataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddOdometryDataRequest* internal_default_instance() {
    return reinterpret_cast<const AddOdometryDataRequest*>(
               &_AddOdometryDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(AddOdometryDataRequest* other);
  friend void swap(AddOdometryDataRequest& a, AddOdometryDataRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddOdometryDataRequest* New() const final {
    return CreateMaybeMessage<AddOdometryDataRequest>(NULL);
  }

  AddOdometryDataRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddOdometryDataRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddOdometryDataRequest& from);
  void MergeFrom(const AddOdometryDataRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddOdometryDataRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cartographer.cloud.proto.SensorMetadata sensor_metadata = 1;
  bool has_sensor_metadata() const;
  void clear_sensor_metadata();
  static const int kSensorMetadataFieldNumber = 1;
  private:
  const ::cartographer::cloud::proto::SensorMetadata& _internal_sensor_metadata() const;
  public:
  const ::cartographer::cloud::proto::SensorMetadata& sensor_metadata() const;
  ::cartographer::cloud::proto::SensorMetadata* release_sensor_metadata();
  ::cartographer::cloud::proto::SensorMetadata* mutable_sensor_metadata();
  void set_allocated_sensor_metadata(::cartographer::cloud::proto::SensorMetadata* sensor_metadata);

  // .cartographer.sensor.proto.OdometryData odometry_data = 2;
  bool has_odometry_data() const;
  void clear_odometry_data();
  static const int kOdometryDataFieldNumber = 2;
  private:
  const ::cartographer::sensor::proto::OdometryData& _internal_odometry_data() const;
  public:
  const ::cartographer::sensor::proto::OdometryData& odometry_data() const;
  ::cartographer::sensor::proto::OdometryData* release_odometry_data();
  ::cartographer::sensor::proto::OdometryData* mutable_odometry_data();
  void set_allocated_odometry_data(::cartographer::sensor::proto::OdometryData* odometry_data);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.AddOdometryDataRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::cloud::proto::SensorMetadata* sensor_metadata_;
  ::cartographer::sensor::proto::OdometryData* odometry_data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddImuDataRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.AddImuDataRequest) */ {
 public:
  AddImuDataRequest();
  virtual ~AddImuDataRequest();

  AddImuDataRequest(const AddImuDataRequest& from);

  inline AddImuDataRequest& operator=(const AddImuDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddImuDataRequest(AddImuDataRequest&& from) noexcept
    : AddImuDataRequest() {
    *this = ::std::move(from);
  }

  inline AddImuDataRequest& operator=(AddImuDataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddImuDataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddImuDataRequest* internal_default_instance() {
    return reinterpret_cast<const AddImuDataRequest*>(
               &_AddImuDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(AddImuDataRequest* other);
  friend void swap(AddImuDataRequest& a, AddImuDataRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddImuDataRequest* New() const final {
    return CreateMaybeMessage<AddImuDataRequest>(NULL);
  }

  AddImuDataRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddImuDataRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddImuDataRequest& from);
  void MergeFrom(const AddImuDataRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddImuDataRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cartographer.cloud.proto.SensorMetadata sensor_metadata = 1;
  bool has_sensor_metadata() const;
  void clear_sensor_metadata();
  static const int kSensorMetadataFieldNumber = 1;
  private:
  const ::cartographer::cloud::proto::SensorMetadata& _internal_sensor_metadata() const;
  public:
  const ::cartographer::cloud::proto::SensorMetadata& sensor_metadata() const;
  ::cartographer::cloud::proto::SensorMetadata* release_sensor_metadata();
  ::cartographer::cloud::proto::SensorMetadata* mutable_sensor_metadata();
  void set_allocated_sensor_metadata(::cartographer::cloud::proto::SensorMetadata* sensor_metadata);

  // .cartographer.sensor.proto.ImuData imu_data = 2;
  bool has_imu_data() const;
  void clear_imu_data();
  static const int kImuDataFieldNumber = 2;
  private:
  const ::cartographer::sensor::proto::ImuData& _internal_imu_data() const;
  public:
  const ::cartographer::sensor::proto::ImuData& imu_data() const;
  ::cartographer::sensor::proto::ImuData* release_imu_data();
  ::cartographer::sensor::proto::ImuData* mutable_imu_data();
  void set_allocated_imu_data(::cartographer::sensor::proto::ImuData* imu_data);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.AddImuDataRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::cloud::proto::SensorMetadata* sensor_metadata_;
  ::cartographer::sensor::proto::ImuData* imu_data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddRangefinderDataRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.AddRangefinderDataRequest) */ {
 public:
  AddRangefinderDataRequest();
  virtual ~AddRangefinderDataRequest();

  AddRangefinderDataRequest(const AddRangefinderDataRequest& from);

  inline AddRangefinderDataRequest& operator=(const AddRangefinderDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddRangefinderDataRequest(AddRangefinderDataRequest&& from) noexcept
    : AddRangefinderDataRequest() {
    *this = ::std::move(from);
  }

  inline AddRangefinderDataRequest& operator=(AddRangefinderDataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddRangefinderDataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddRangefinderDataRequest* internal_default_instance() {
    return reinterpret_cast<const AddRangefinderDataRequest*>(
               &_AddRangefinderDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(AddRangefinderDataRequest* other);
  friend void swap(AddRangefinderDataRequest& a, AddRangefinderDataRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddRangefinderDataRequest* New() const final {
    return CreateMaybeMessage<AddRangefinderDataRequest>(NULL);
  }

  AddRangefinderDataRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddRangefinderDataRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddRangefinderDataRequest& from);
  void MergeFrom(const AddRangefinderDataRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddRangefinderDataRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cartographer.cloud.proto.SensorMetadata sensor_metadata = 1;
  bool has_sensor_metadata() const;
  void clear_sensor_metadata();
  static const int kSensorMetadataFieldNumber = 1;
  private:
  const ::cartographer::cloud::proto::SensorMetadata& _internal_sensor_metadata() const;
  public:
  const ::cartographer::cloud::proto::SensorMetadata& sensor_metadata() const;
  ::cartographer::cloud::proto::SensorMetadata* release_sensor_metadata();
  ::cartographer::cloud::proto::SensorMetadata* mutable_sensor_metadata();
  void set_allocated_sensor_metadata(::cartographer::cloud::proto::SensorMetadata* sensor_metadata);

  // .cartographer.sensor.proto.TimedPointCloudData timed_point_cloud_data = 2;
  bool has_timed_point_cloud_data() const;
  void clear_timed_point_cloud_data();
  static const int kTimedPointCloudDataFieldNumber = 2;
  private:
  const ::cartographer::sensor::proto::TimedPointCloudData& _internal_timed_point_cloud_data() const;
  public:
  const ::cartographer::sensor::proto::TimedPointCloudData& timed_point_cloud_data() const;
  ::cartographer::sensor::proto::TimedPointCloudData* release_timed_point_cloud_data();
  ::cartographer::sensor::proto::TimedPointCloudData* mutable_timed_point_cloud_data();
  void set_allocated_timed_point_cloud_data(::cartographer::sensor::proto::TimedPointCloudData* timed_point_cloud_data);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.AddRangefinderDataRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::cloud::proto::SensorMetadata* sensor_metadata_;
  ::cartographer::sensor::proto::TimedPointCloudData* timed_point_cloud_data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddFixedFramePoseDataRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.AddFixedFramePoseDataRequest) */ {
 public:
  AddFixedFramePoseDataRequest();
  virtual ~AddFixedFramePoseDataRequest();

  AddFixedFramePoseDataRequest(const AddFixedFramePoseDataRequest& from);

  inline AddFixedFramePoseDataRequest& operator=(const AddFixedFramePoseDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddFixedFramePoseDataRequest(AddFixedFramePoseDataRequest&& from) noexcept
    : AddFixedFramePoseDataRequest() {
    *this = ::std::move(from);
  }

  inline AddFixedFramePoseDataRequest& operator=(AddFixedFramePoseDataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddFixedFramePoseDataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddFixedFramePoseDataRequest* internal_default_instance() {
    return reinterpret_cast<const AddFixedFramePoseDataRequest*>(
               &_AddFixedFramePoseDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(AddFixedFramePoseDataRequest* other);
  friend void swap(AddFixedFramePoseDataRequest& a, AddFixedFramePoseDataRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddFixedFramePoseDataRequest* New() const final {
    return CreateMaybeMessage<AddFixedFramePoseDataRequest>(NULL);
  }

  AddFixedFramePoseDataRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddFixedFramePoseDataRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddFixedFramePoseDataRequest& from);
  void MergeFrom(const AddFixedFramePoseDataRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddFixedFramePoseDataRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cartographer.cloud.proto.SensorMetadata sensor_metadata = 1;
  bool has_sensor_metadata() const;
  void clear_sensor_metadata();
  static const int kSensorMetadataFieldNumber = 1;
  private:
  const ::cartographer::cloud::proto::SensorMetadata& _internal_sensor_metadata() const;
  public:
  const ::cartographer::cloud::proto::SensorMetadata& sensor_metadata() const;
  ::cartographer::cloud::proto::SensorMetadata* release_sensor_metadata();
  ::cartographer::cloud::proto::SensorMetadata* mutable_sensor_metadata();
  void set_allocated_sensor_metadata(::cartographer::cloud::proto::SensorMetadata* sensor_metadata);

  // .cartographer.sensor.proto.FixedFramePoseData fixed_frame_pose_data = 2;
  bool has_fixed_frame_pose_data() const;
  void clear_fixed_frame_pose_data();
  static const int kFixedFramePoseDataFieldNumber = 2;
  private:
  const ::cartographer::sensor::proto::FixedFramePoseData& _internal_fixed_frame_pose_data() const;
  public:
  const ::cartographer::sensor::proto::FixedFramePoseData& fixed_frame_pose_data() const;
  ::cartographer::sensor::proto::FixedFramePoseData* release_fixed_frame_pose_data();
  ::cartographer::sensor::proto::FixedFramePoseData* mutable_fixed_frame_pose_data();
  void set_allocated_fixed_frame_pose_data(::cartographer::sensor::proto::FixedFramePoseData* fixed_frame_pose_data);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.AddFixedFramePoseDataRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::cloud::proto::SensorMetadata* sensor_metadata_;
  ::cartographer::sensor::proto::FixedFramePoseData* fixed_frame_pose_data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddLandmarkDataRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.AddLandmarkDataRequest) */ {
 public:
  AddLandmarkDataRequest();
  virtual ~AddLandmarkDataRequest();

  AddLandmarkDataRequest(const AddLandmarkDataRequest& from);

  inline AddLandmarkDataRequest& operator=(const AddLandmarkDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddLandmarkDataRequest(AddLandmarkDataRequest&& from) noexcept
    : AddLandmarkDataRequest() {
    *this = ::std::move(from);
  }

  inline AddLandmarkDataRequest& operator=(AddLandmarkDataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddLandmarkDataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddLandmarkDataRequest* internal_default_instance() {
    return reinterpret_cast<const AddLandmarkDataRequest*>(
               &_AddLandmarkDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(AddLandmarkDataRequest* other);
  friend void swap(AddLandmarkDataRequest& a, AddLandmarkDataRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddLandmarkDataRequest* New() const final {
    return CreateMaybeMessage<AddLandmarkDataRequest>(NULL);
  }

  AddLandmarkDataRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddLandmarkDataRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddLandmarkDataRequest& from);
  void MergeFrom(const AddLandmarkDataRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddLandmarkDataRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cartographer.cloud.proto.SensorMetadata sensor_metadata = 1;
  bool has_sensor_metadata() const;
  void clear_sensor_metadata();
  static const int kSensorMetadataFieldNumber = 1;
  private:
  const ::cartographer::cloud::proto::SensorMetadata& _internal_sensor_metadata() const;
  public:
  const ::cartographer::cloud::proto::SensorMetadata& sensor_metadata() const;
  ::cartographer::cloud::proto::SensorMetadata* release_sensor_metadata();
  ::cartographer::cloud::proto::SensorMetadata* mutable_sensor_metadata();
  void set_allocated_sensor_metadata(::cartographer::cloud::proto::SensorMetadata* sensor_metadata);

  // .cartographer.sensor.proto.LandmarkData landmark_data = 2;
  bool has_landmark_data() const;
  void clear_landmark_data();
  static const int kLandmarkDataFieldNumber = 2;
  private:
  const ::cartographer::sensor::proto::LandmarkData& _internal_landmark_data() const;
  public:
  const ::cartographer::sensor::proto::LandmarkData& landmark_data() const;
  ::cartographer::sensor::proto::LandmarkData* release_landmark_data();
  ::cartographer::sensor::proto::LandmarkData* mutable_landmark_data();
  void set_allocated_landmark_data(::cartographer::sensor::proto::LandmarkData* landmark_data);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.AddLandmarkDataRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::cloud::proto::SensorMetadata* sensor_metadata_;
  ::cartographer::sensor::proto::LandmarkData* landmark_data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FinishTrajectoryRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.FinishTrajectoryRequest) */ {
 public:
  FinishTrajectoryRequest();
  virtual ~FinishTrajectoryRequest();

  FinishTrajectoryRequest(const FinishTrajectoryRequest& from);

  inline FinishTrajectoryRequest& operator=(const FinishTrajectoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FinishTrajectoryRequest(FinishTrajectoryRequest&& from) noexcept
    : FinishTrajectoryRequest() {
    *this = ::std::move(from);
  }

  inline FinishTrajectoryRequest& operator=(FinishTrajectoryRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FinishTrajectoryRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FinishTrajectoryRequest* internal_default_instance() {
    return reinterpret_cast<const FinishTrajectoryRequest*>(
               &_FinishTrajectoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(FinishTrajectoryRequest* other);
  friend void swap(FinishTrajectoryRequest& a, FinishTrajectoryRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FinishTrajectoryRequest* New() const final {
    return CreateMaybeMessage<FinishTrajectoryRequest>(NULL);
  }

  FinishTrajectoryRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FinishTrajectoryRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FinishTrajectoryRequest& from);
  void MergeFrom(const FinishTrajectoryRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FinishTrajectoryRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string client_id = 2;
  void clear_client_id();
  static const int kClientIdFieldNumber = 2;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  #if LANG_CXX11
  void set_client_id(::std::string&& value);
  #endif
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  // int32 trajectory_id = 1;
  void clear_trajectory_id();
  static const int kTrajectoryIdFieldNumber = 1;
  ::google::protobuf::int32 trajectory_id() const;
  void set_trajectory_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.FinishTrajectoryRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr client_id_;
  ::google::protobuf::int32 trajectory_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteTrajectoryRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.DeleteTrajectoryRequest) */ {
 public:
  DeleteTrajectoryRequest();
  virtual ~DeleteTrajectoryRequest();

  DeleteTrajectoryRequest(const DeleteTrajectoryRequest& from);

  inline DeleteTrajectoryRequest& operator=(const DeleteTrajectoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteTrajectoryRequest(DeleteTrajectoryRequest&& from) noexcept
    : DeleteTrajectoryRequest() {
    *this = ::std::move(from);
  }

  inline DeleteTrajectoryRequest& operator=(DeleteTrajectoryRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteTrajectoryRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteTrajectoryRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteTrajectoryRequest*>(
               &_DeleteTrajectoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(DeleteTrajectoryRequest* other);
  friend void swap(DeleteTrajectoryRequest& a, DeleteTrajectoryRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteTrajectoryRequest* New() const final {
    return CreateMaybeMessage<DeleteTrajectoryRequest>(NULL);
  }

  DeleteTrajectoryRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteTrajectoryRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteTrajectoryRequest& from);
  void MergeFrom(const DeleteTrajectoryRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteTrajectoryRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string client_id = 2;
  void clear_client_id();
  static const int kClientIdFieldNumber = 2;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  #if LANG_CXX11
  void set_client_id(::std::string&& value);
  #endif
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  // int32 trajectory_id = 1;
  void clear_trajectory_id();
  static const int kTrajectoryIdFieldNumber = 1;
  ::google::protobuf::int32 trajectory_id() const;
  void set_trajectory_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.DeleteTrajectoryRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr client_id_;
  ::google::protobuf::int32 trajectory_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReceiveLocalSlamResultsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.ReceiveLocalSlamResultsRequest) */ {
 public:
  ReceiveLocalSlamResultsRequest();
  virtual ~ReceiveLocalSlamResultsRequest();

  ReceiveLocalSlamResultsRequest(const ReceiveLocalSlamResultsRequest& from);

  inline ReceiveLocalSlamResultsRequest& operator=(const ReceiveLocalSlamResultsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReceiveLocalSlamResultsRequest(ReceiveLocalSlamResultsRequest&& from) noexcept
    : ReceiveLocalSlamResultsRequest() {
    *this = ::std::move(from);
  }

  inline ReceiveLocalSlamResultsRequest& operator=(ReceiveLocalSlamResultsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiveLocalSlamResultsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReceiveLocalSlamResultsRequest* internal_default_instance() {
    return reinterpret_cast<const ReceiveLocalSlamResultsRequest*>(
               &_ReceiveLocalSlamResultsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ReceiveLocalSlamResultsRequest* other);
  friend void swap(ReceiveLocalSlamResultsRequest& a, ReceiveLocalSlamResultsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReceiveLocalSlamResultsRequest* New() const final {
    return CreateMaybeMessage<ReceiveLocalSlamResultsRequest>(NULL);
  }

  ReceiveLocalSlamResultsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReceiveLocalSlamResultsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReceiveLocalSlamResultsRequest& from);
  void MergeFrom(const ReceiveLocalSlamResultsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceiveLocalSlamResultsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 trajectory_id = 1;
  void clear_trajectory_id();
  static const int kTrajectoryIdFieldNumber = 1;
  ::google::protobuf::int32 trajectory_id() const;
  void set_trajectory_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.ReceiveLocalSlamResultsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 trajectory_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LocalSlamInsertionResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.LocalSlamInsertionResult) */ {
 public:
  LocalSlamInsertionResult();
  virtual ~LocalSlamInsertionResult();

  LocalSlamInsertionResult(const LocalSlamInsertionResult& from);

  inline LocalSlamInsertionResult& operator=(const LocalSlamInsertionResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LocalSlamInsertionResult(LocalSlamInsertionResult&& from) noexcept
    : LocalSlamInsertionResult() {
    *this = ::std::move(from);
  }

  inline LocalSlamInsertionResult& operator=(LocalSlamInsertionResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalSlamInsertionResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocalSlamInsertionResult* internal_default_instance() {
    return reinterpret_cast<const LocalSlamInsertionResult*>(
               &_LocalSlamInsertionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(LocalSlamInsertionResult* other);
  friend void swap(LocalSlamInsertionResult& a, LocalSlamInsertionResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LocalSlamInsertionResult* New() const final {
    return CreateMaybeMessage<LocalSlamInsertionResult>(NULL);
  }

  LocalSlamInsertionResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LocalSlamInsertionResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LocalSlamInsertionResult& from);
  void MergeFrom(const LocalSlamInsertionResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalSlamInsertionResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cartographer.mapping.proto.NodeId node_id = 1;
  bool has_node_id() const;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  private:
  const ::cartographer::mapping::proto::NodeId& _internal_node_id() const;
  public:
  const ::cartographer::mapping::proto::NodeId& node_id() const;
  ::cartographer::mapping::proto::NodeId* release_node_id();
  ::cartographer::mapping::proto::NodeId* mutable_node_id();
  void set_allocated_node_id(::cartographer::mapping::proto::NodeId* node_id);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.LocalSlamInsertionResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::mapping::proto::NodeId* node_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReceiveLocalSlamResultsResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse) */ {
 public:
  ReceiveLocalSlamResultsResponse();
  virtual ~ReceiveLocalSlamResultsResponse();

  ReceiveLocalSlamResultsResponse(const ReceiveLocalSlamResultsResponse& from);

  inline ReceiveLocalSlamResultsResponse& operator=(const ReceiveLocalSlamResultsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReceiveLocalSlamResultsResponse(ReceiveLocalSlamResultsResponse&& from) noexcept
    : ReceiveLocalSlamResultsResponse() {
    *this = ::std::move(from);
  }

  inline ReceiveLocalSlamResultsResponse& operator=(ReceiveLocalSlamResultsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiveLocalSlamResultsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReceiveLocalSlamResultsResponse* internal_default_instance() {
    return reinterpret_cast<const ReceiveLocalSlamResultsResponse*>(
               &_ReceiveLocalSlamResultsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(ReceiveLocalSlamResultsResponse* other);
  friend void swap(ReceiveLocalSlamResultsResponse& a, ReceiveLocalSlamResultsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReceiveLocalSlamResultsResponse* New() const final {
    return CreateMaybeMessage<ReceiveLocalSlamResultsResponse>(NULL);
  }

  ReceiveLocalSlamResultsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReceiveLocalSlamResultsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReceiveLocalSlamResultsResponse& from);
  void MergeFrom(const ReceiveLocalSlamResultsResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceiveLocalSlamResultsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cartographer.transform.proto.Rigid3d local_pose = 3;
  bool has_local_pose() const;
  void clear_local_pose();
  static const int kLocalPoseFieldNumber = 3;
  private:
  const ::cartographer::transform::proto::Rigid3d& _internal_local_pose() const;
  public:
  const ::cartographer::transform::proto::Rigid3d& local_pose() const;
  ::cartographer::transform::proto::Rigid3d* release_local_pose();
  ::cartographer::transform::proto::Rigid3d* mutable_local_pose();
  void set_allocated_local_pose(::cartographer::transform::proto::Rigid3d* local_pose);

  // .cartographer.sensor.proto.RangeData range_data = 4;
  bool has_range_data() const;
  void clear_range_data();
  static const int kRangeDataFieldNumber = 4;
  private:
  const ::cartographer::sensor::proto::RangeData& _internal_range_data() const;
  public:
  const ::cartographer::sensor::proto::RangeData& range_data() const;
  ::cartographer::sensor::proto::RangeData* release_range_data();
  ::cartographer::sensor::proto::RangeData* mutable_range_data();
  void set_allocated_range_data(::cartographer::sensor::proto::RangeData* range_data);

  // .cartographer.cloud.proto.LocalSlamInsertionResult insertion_result = 5;
  bool has_insertion_result() const;
  void clear_insertion_result();
  static const int kInsertionResultFieldNumber = 5;
  private:
  const ::cartographer::cloud::proto::LocalSlamInsertionResult& _internal_insertion_result() const;
  public:
  const ::cartographer::cloud::proto::LocalSlamInsertionResult& insertion_result() const;
  ::cartographer::cloud::proto::LocalSlamInsertionResult* release_insertion_result();
  ::cartographer::cloud::proto::LocalSlamInsertionResult* mutable_insertion_result();
  void set_allocated_insertion_result(::cartographer::cloud::proto::LocalSlamInsertionResult* insertion_result);

  // int64 timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int32 trajectory_id = 1;
  void clear_trajectory_id();
  static const int kTrajectoryIdFieldNumber = 1;
  ::google::protobuf::int32 trajectory_id() const;
  void set_trajectory_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::transform::proto::Rigid3d* local_pose_;
  ::cartographer::sensor::proto::RangeData* range_data_;
  ::cartographer::cloud::proto::LocalSlamInsertionResult* insertion_result_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int32 trajectory_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse, 
    ::google::protobuf::int32, ::cartographer::mapping::proto::NodeId,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse, 
    ::google::protobuf::int32, ::cartographer::mapping::proto::NodeId,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse();
  ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse& other);
  static const ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse*>(&_ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse, 
    ::google::protobuf::int32, ::cartographer::mapping::proto::SubmapId,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse, 
    ::google::protobuf::int32, ::cartographer::mapping::proto::SubmapId,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse();
  ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse& other);
  static const ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse*>(&_ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class ReceiveGlobalSlamOptimizationsResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.ReceiveGlobalSlamOptimizationsResponse) */ {
 public:
  ReceiveGlobalSlamOptimizationsResponse();
  virtual ~ReceiveGlobalSlamOptimizationsResponse();

  ReceiveGlobalSlamOptimizationsResponse(const ReceiveGlobalSlamOptimizationsResponse& from);

  inline ReceiveGlobalSlamOptimizationsResponse& operator=(const ReceiveGlobalSlamOptimizationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReceiveGlobalSlamOptimizationsResponse(ReceiveGlobalSlamOptimizationsResponse&& from) noexcept
    : ReceiveGlobalSlamOptimizationsResponse() {
    *this = ::std::move(from);
  }

  inline ReceiveGlobalSlamOptimizationsResponse& operator=(ReceiveGlobalSlamOptimizationsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiveGlobalSlamOptimizationsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReceiveGlobalSlamOptimizationsResponse* internal_default_instance() {
    return reinterpret_cast<const ReceiveGlobalSlamOptimizationsResponse*>(
               &_ReceiveGlobalSlamOptimizationsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(ReceiveGlobalSlamOptimizationsResponse* other);
  friend void swap(ReceiveGlobalSlamOptimizationsResponse& a, ReceiveGlobalSlamOptimizationsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReceiveGlobalSlamOptimizationsResponse* New() const final {
    return CreateMaybeMessage<ReceiveGlobalSlamOptimizationsResponse>(NULL);
  }

  ReceiveGlobalSlamOptimizationsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReceiveGlobalSlamOptimizationsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReceiveGlobalSlamOptimizationsResponse& from);
  void MergeFrom(const ReceiveGlobalSlamOptimizationsResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceiveGlobalSlamOptimizationsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<int32, .cartographer.mapping.proto.NodeId> last_optimized_node_ids = 1;
  int last_optimized_node_ids_size() const;
  void clear_last_optimized_node_ids();
  static const int kLastOptimizedNodeIdsFieldNumber = 1;
  const ::google::protobuf::Map< ::google::protobuf::int32, ::cartographer::mapping::proto::NodeId >&
      last_optimized_node_ids() const;
  ::google::protobuf::Map< ::google::protobuf::int32, ::cartographer::mapping::proto::NodeId >*
      mutable_last_optimized_node_ids();

  // map<int32, .cartographer.mapping.proto.SubmapId> last_optimized_submap_ids = 2;
  int last_optimized_submap_ids_size() const;
  void clear_last_optimized_submap_ids();
  static const int kLastOptimizedSubmapIdsFieldNumber = 2;
  const ::google::protobuf::Map< ::google::protobuf::int32, ::cartographer::mapping::proto::SubmapId >&
      last_optimized_submap_ids() const;
  ::google::protobuf::Map< ::google::protobuf::int32, ::cartographer::mapping::proto::SubmapId >*
      mutable_last_optimized_submap_ids();

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.ReceiveGlobalSlamOptimizationsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse,
      ::google::protobuf::int32, ::cartographer::mapping::proto::NodeId,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > last_optimized_node_ids_;
  ::google::protobuf::internal::MapField<
      ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse,
      ::google::protobuf::int32, ::cartographer::mapping::proto::SubmapId,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > last_optimized_submap_ids_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetSubmapRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.GetSubmapRequest) */ {
 public:
  GetSubmapRequest();
  virtual ~GetSubmapRequest();

  GetSubmapRequest(const GetSubmapRequest& from);

  inline GetSubmapRequest& operator=(const GetSubmapRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetSubmapRequest(GetSubmapRequest&& from) noexcept
    : GetSubmapRequest() {
    *this = ::std::move(from);
  }

  inline GetSubmapRequest& operator=(GetSubmapRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSubmapRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetSubmapRequest* internal_default_instance() {
    return reinterpret_cast<const GetSubmapRequest*>(
               &_GetSubmapRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(GetSubmapRequest* other);
  friend void swap(GetSubmapRequest& a, GetSubmapRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetSubmapRequest* New() const final {
    return CreateMaybeMessage<GetSubmapRequest>(NULL);
  }

  GetSubmapRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetSubmapRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetSubmapRequest& from);
  void MergeFrom(const GetSubmapRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSubmapRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cartographer.mapping.proto.SubmapId submap_id = 1;
  bool has_submap_id() const;
  void clear_submap_id();
  static const int kSubmapIdFieldNumber = 1;
  private:
  const ::cartographer::mapping::proto::SubmapId& _internal_submap_id() const;
  public:
  const ::cartographer::mapping::proto::SubmapId& submap_id() const;
  ::cartographer::mapping::proto::SubmapId* release_submap_id();
  ::cartographer::mapping::proto::SubmapId* mutable_submap_id();
  void set_allocated_submap_id(::cartographer::mapping::proto::SubmapId* submap_id);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.GetSubmapRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::mapping::proto::SubmapId* submap_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoadStateRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.LoadStateRequest) */ {
 public:
  LoadStateRequest();
  virtual ~LoadStateRequest();

  LoadStateRequest(const LoadStateRequest& from);

  inline LoadStateRequest& operator=(const LoadStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoadStateRequest(LoadStateRequest&& from) noexcept
    : LoadStateRequest() {
    *this = ::std::move(from);
  }

  inline LoadStateRequest& operator=(LoadStateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadStateRequest& default_instance();

  enum StateChunkCase {
    kSerializedData = 1,
    kSerializationHeader = 2,
    kClientId = 3,
    STATE_CHUNK_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadStateRequest* internal_default_instance() {
    return reinterpret_cast<const LoadStateRequest*>(
               &_LoadStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(LoadStateRequest* other);
  friend void swap(LoadStateRequest& a, LoadStateRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoadStateRequest* New() const final {
    return CreateMaybeMessage<LoadStateRequest>(NULL);
  }

  LoadStateRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoadStateRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LoadStateRequest& from);
  void MergeFrom(const LoadStateRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadStateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool load_frozen_state = 4;
  void clear_load_frozen_state();
  static const int kLoadFrozenStateFieldNumber = 4;
  bool load_frozen_state() const;
  void set_load_frozen_state(bool value);

  // .cartographer.mapping.proto.SerializedData serialized_data = 1;
  bool has_serialized_data() const;
  void clear_serialized_data();
  static const int kSerializedDataFieldNumber = 1;
  private:
  const ::cartographer::mapping::proto::SerializedData& _internal_serialized_data() const;
  public:
  const ::cartographer::mapping::proto::SerializedData& serialized_data() const;
  ::cartographer::mapping::proto::SerializedData* release_serialized_data();
  ::cartographer::mapping::proto::SerializedData* mutable_serialized_data();
  void set_allocated_serialized_data(::cartographer::mapping::proto::SerializedData* serialized_data);

  // .cartographer.mapping.proto.SerializationHeader serialization_header = 2;
  bool has_serialization_header() const;
  void clear_serialization_header();
  static const int kSerializationHeaderFieldNumber = 2;
  private:
  const ::cartographer::mapping::proto::SerializationHeader& _internal_serialization_header() const;
  public:
  const ::cartographer::mapping::proto::SerializationHeader& serialization_header() const;
  ::cartographer::mapping::proto::SerializationHeader* release_serialization_header();
  ::cartographer::mapping::proto::SerializationHeader* mutable_serialization_header();
  void set_allocated_serialization_header(::cartographer::mapping::proto::SerializationHeader* serialization_header);

  // string client_id = 3;
  private:
  bool has_client_id() const;
  public:
  void clear_client_id();
  static const int kClientIdFieldNumber = 3;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  #if LANG_CXX11
  void set_client_id(::std::string&& value);
  #endif
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  void clear_state_chunk();
  StateChunkCase state_chunk_case() const;
  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.LoadStateRequest)
 private:
  void set_has_serialized_data();
  void set_has_serialization_header();
  void set_has_client_id();

  inline bool has_state_chunk() const;
  inline void clear_has_state_chunk();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool load_frozen_state_;
  union StateChunkUnion {
    StateChunkUnion() {}
    ::cartographer::mapping::proto::SerializedData* serialized_data_;
    ::cartographer::mapping::proto::SerializationHeader* serialization_header_;
    ::google::protobuf::internal::ArenaStringPtr client_id_;
  } state_chunk_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse, 
    ::google::protobuf::int32, ::google::protobuf::int32,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse, 
    ::google::protobuf::int32, ::google::protobuf::int32,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    0 > SuperType;
  TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse();
  TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse& other);
  static const TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse*>(&_TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class TrajectoryRemapping : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.TrajectoryRemapping) */ {
 public:
  TrajectoryRemapping();
  virtual ~TrajectoryRemapping();

  TrajectoryRemapping(const TrajectoryRemapping& from);

  inline TrajectoryRemapping& operator=(const TrajectoryRemapping& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrajectoryRemapping(TrajectoryRemapping&& from) noexcept
    : TrajectoryRemapping() {
    *this = ::std::move(from);
  }

  inline TrajectoryRemapping& operator=(TrajectoryRemapping&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrajectoryRemapping& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrajectoryRemapping* internal_default_instance() {
    return reinterpret_cast<const TrajectoryRemapping*>(
               &_TrajectoryRemapping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(TrajectoryRemapping* other);
  friend void swap(TrajectoryRemapping& a, TrajectoryRemapping& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrajectoryRemapping* New() const final {
    return CreateMaybeMessage<TrajectoryRemapping>(NULL);
  }

  TrajectoryRemapping* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrajectoryRemapping>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrajectoryRemapping& from);
  void MergeFrom(const TrajectoryRemapping& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrajectoryRemapping* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<int32, int32> serialized_trajectories_to_trajectories = 1;
  int serialized_trajectories_to_trajectories_size() const;
  void clear_serialized_trajectories_to_trajectories();
  static const int kSerializedTrajectoriesToTrajectoriesFieldNumber = 1;
  const ::google::protobuf::Map< ::google::protobuf::int32, ::google::protobuf::int32 >&
      serialized_trajectories_to_trajectories() const;
  ::google::protobuf::Map< ::google::protobuf::int32, ::google::protobuf::int32 >*
      mutable_serialized_trajectories_to_trajectories();

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.TrajectoryRemapping)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse,
      ::google::protobuf::int32, ::google::protobuf::int32,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      0 > serialized_trajectories_to_trajectories_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoadStateResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.LoadStateResponse) */ {
 public:
  LoadStateResponse();
  virtual ~LoadStateResponse();

  LoadStateResponse(const LoadStateResponse& from);

  inline LoadStateResponse& operator=(const LoadStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoadStateResponse(LoadStateResponse&& from) noexcept
    : LoadStateResponse() {
    *this = ::std::move(from);
  }

  inline LoadStateResponse& operator=(LoadStateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadStateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadStateResponse* internal_default_instance() {
    return reinterpret_cast<const LoadStateResponse*>(
               &_LoadStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(LoadStateResponse* other);
  friend void swap(LoadStateResponse& a, LoadStateResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoadStateResponse* New() const final {
    return CreateMaybeMessage<LoadStateResponse>(NULL);
  }

  LoadStateResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoadStateResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LoadStateResponse& from);
  void MergeFrom(const LoadStateResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadStateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cartographer.cloud.proto.TrajectoryRemapping trajectory_remapping = 1;
  bool has_trajectory_remapping() const;
  void clear_trajectory_remapping();
  static const int kTrajectoryRemappingFieldNumber = 1;
  private:
  const ::cartographer::cloud::proto::TrajectoryRemapping& _internal_trajectory_remapping() const;
  public:
  const ::cartographer::cloud::proto::TrajectoryRemapping& trajectory_remapping() const;
  ::cartographer::cloud::proto::TrajectoryRemapping* release_trajectory_remapping();
  ::cartographer::cloud::proto::TrajectoryRemapping* mutable_trajectory_remapping();
  void set_allocated_trajectory_remapping(::cartographer::cloud::proto::TrajectoryRemapping* trajectory_remapping);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.LoadStateResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::cloud::proto::TrajectoryRemapping* trajectory_remapping_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoadStateFromFileRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.LoadStateFromFileRequest) */ {
 public:
  LoadStateFromFileRequest();
  virtual ~LoadStateFromFileRequest();

  LoadStateFromFileRequest(const LoadStateFromFileRequest& from);

  inline LoadStateFromFileRequest& operator=(const LoadStateFromFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoadStateFromFileRequest(LoadStateFromFileRequest&& from) noexcept
    : LoadStateFromFileRequest() {
    *this = ::std::move(from);
  }

  inline LoadStateFromFileRequest& operator=(LoadStateFromFileRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadStateFromFileRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadStateFromFileRequest* internal_default_instance() {
    return reinterpret_cast<const LoadStateFromFileRequest*>(
               &_LoadStateFromFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(LoadStateFromFileRequest* other);
  friend void swap(LoadStateFromFileRequest& a, LoadStateFromFileRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoadStateFromFileRequest* New() const final {
    return CreateMaybeMessage<LoadStateFromFileRequest>(NULL);
  }

  LoadStateFromFileRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoadStateFromFileRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LoadStateFromFileRequest& from);
  void MergeFrom(const LoadStateFromFileRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadStateFromFileRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string file_path = 1;
  void clear_file_path();
  static const int kFilePathFieldNumber = 1;
  const ::std::string& file_path() const;
  void set_file_path(const ::std::string& value);
  #if LANG_CXX11
  void set_file_path(::std::string&& value);
  #endif
  void set_file_path(const char* value);
  void set_file_path(const char* value, size_t size);
  ::std::string* mutable_file_path();
  ::std::string* release_file_path();
  void set_allocated_file_path(::std::string* file_path);

  // string client_id = 2;
  void clear_client_id();
  static const int kClientIdFieldNumber = 2;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  #if LANG_CXX11
  void set_client_id(::std::string&& value);
  #endif
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  // bool load_frozen_state = 3;
  void clear_load_frozen_state();
  static const int kLoadFrozenStateFieldNumber = 3;
  bool load_frozen_state() const;
  void set_load_frozen_state(bool value);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.LoadStateFromFileRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr file_path_;
  ::google::protobuf::internal::ArenaStringPtr client_id_;
  bool load_frozen_state_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoadStateFromFileResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.LoadStateFromFileResponse) */ {
 public:
  LoadStateFromFileResponse();
  virtual ~LoadStateFromFileResponse();

  LoadStateFromFileResponse(const LoadStateFromFileResponse& from);

  inline LoadStateFromFileResponse& operator=(const LoadStateFromFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoadStateFromFileResponse(LoadStateFromFileResponse&& from) noexcept
    : LoadStateFromFileResponse() {
    *this = ::std::move(from);
  }

  inline LoadStateFromFileResponse& operator=(LoadStateFromFileResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadStateFromFileResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadStateFromFileResponse* internal_default_instance() {
    return reinterpret_cast<const LoadStateFromFileResponse*>(
               &_LoadStateFromFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(LoadStateFromFileResponse* other);
  friend void swap(LoadStateFromFileResponse& a, LoadStateFromFileResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoadStateFromFileResponse* New() const final {
    return CreateMaybeMessage<LoadStateFromFileResponse>(NULL);
  }

  LoadStateFromFileResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoadStateFromFileResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LoadStateFromFileResponse& from);
  void MergeFrom(const LoadStateFromFileResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadStateFromFileResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cartographer.cloud.proto.TrajectoryRemapping trajectory_remapping = 1;
  bool has_trajectory_remapping() const;
  void clear_trajectory_remapping();
  static const int kTrajectoryRemappingFieldNumber = 1;
  private:
  const ::cartographer::cloud::proto::TrajectoryRemapping& _internal_trajectory_remapping() const;
  public:
  const ::cartographer::cloud::proto::TrajectoryRemapping& trajectory_remapping() const;
  ::cartographer::cloud::proto::TrajectoryRemapping* release_trajectory_remapping();
  ::cartographer::cloud::proto::TrajectoryRemapping* mutable_trajectory_remapping();
  void set_allocated_trajectory_remapping(::cartographer::cloud::proto::TrajectoryRemapping* trajectory_remapping);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.LoadStateFromFileResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::cloud::proto::TrajectoryRemapping* trajectory_remapping_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetSubmapResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.GetSubmapResponse) */ {
 public:
  GetSubmapResponse();
  virtual ~GetSubmapResponse();

  GetSubmapResponse(const GetSubmapResponse& from);

  inline GetSubmapResponse& operator=(const GetSubmapResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetSubmapResponse(GetSubmapResponse&& from) noexcept
    : GetSubmapResponse() {
    *this = ::std::move(from);
  }

  inline GetSubmapResponse& operator=(GetSubmapResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSubmapResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetSubmapResponse* internal_default_instance() {
    return reinterpret_cast<const GetSubmapResponse*>(
               &_GetSubmapResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(GetSubmapResponse* other);
  friend void swap(GetSubmapResponse& a, GetSubmapResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetSubmapResponse* New() const final {
    return CreateMaybeMessage<GetSubmapResponse>(NULL);
  }

  GetSubmapResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetSubmapResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetSubmapResponse& from);
  void MergeFrom(const GetSubmapResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSubmapResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error_msg = 2;
  void clear_error_msg();
  static const int kErrorMsgFieldNumber = 2;
  const ::std::string& error_msg() const;
  void set_error_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_error_msg(::std::string&& value);
  #endif
  void set_error_msg(const char* value);
  void set_error_msg(const char* value, size_t size);
  ::std::string* mutable_error_msg();
  ::std::string* release_error_msg();
  void set_allocated_error_msg(::std::string* error_msg);

  // .cartographer.mapping.proto.SubmapQuery.Response submap_query_response = 1;
  bool has_submap_query_response() const;
  void clear_submap_query_response();
  static const int kSubmapQueryResponseFieldNumber = 1;
  private:
  const ::cartographer::mapping::proto::SubmapQuery_Response& _internal_submap_query_response() const;
  public:
  const ::cartographer::mapping::proto::SubmapQuery_Response& submap_query_response() const;
  ::cartographer::mapping::proto::SubmapQuery_Response* release_submap_query_response();
  ::cartographer::mapping::proto::SubmapQuery_Response* mutable_submap_query_response();
  void set_allocated_submap_query_response(::cartographer::mapping::proto::SubmapQuery_Response* submap_query_response);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.GetSubmapResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_msg_;
  ::cartographer::mapping::proto::SubmapQuery_Response* submap_query_response_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrajectoryNodePose_ConstantPoseData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.TrajectoryNodePose.ConstantPoseData) */ {
 public:
  TrajectoryNodePose_ConstantPoseData();
  virtual ~TrajectoryNodePose_ConstantPoseData();

  TrajectoryNodePose_ConstantPoseData(const TrajectoryNodePose_ConstantPoseData& from);

  inline TrajectoryNodePose_ConstantPoseData& operator=(const TrajectoryNodePose_ConstantPoseData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrajectoryNodePose_ConstantPoseData(TrajectoryNodePose_ConstantPoseData&& from) noexcept
    : TrajectoryNodePose_ConstantPoseData() {
    *this = ::std::move(from);
  }

  inline TrajectoryNodePose_ConstantPoseData& operator=(TrajectoryNodePose_ConstantPoseData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrajectoryNodePose_ConstantPoseData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrajectoryNodePose_ConstantPoseData* internal_default_instance() {
    return reinterpret_cast<const TrajectoryNodePose_ConstantPoseData*>(
               &_TrajectoryNodePose_ConstantPoseData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(TrajectoryNodePose_ConstantPoseData* other);
  friend void swap(TrajectoryNodePose_ConstantPoseData& a, TrajectoryNodePose_ConstantPoseData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrajectoryNodePose_ConstantPoseData* New() const final {
    return CreateMaybeMessage<TrajectoryNodePose_ConstantPoseData>(NULL);
  }

  TrajectoryNodePose_ConstantPoseData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrajectoryNodePose_ConstantPoseData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrajectoryNodePose_ConstantPoseData& from);
  void MergeFrom(const TrajectoryNodePose_ConstantPoseData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrajectoryNodePose_ConstantPoseData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cartographer.transform.proto.Rigid3d local_pose = 2;
  bool has_local_pose() const;
  void clear_local_pose();
  static const int kLocalPoseFieldNumber = 2;
  private:
  const ::cartographer::transform::proto::Rigid3d& _internal_local_pose() const;
  public:
  const ::cartographer::transform::proto::Rigid3d& local_pose() const;
  ::cartographer::transform::proto::Rigid3d* release_local_pose();
  ::cartographer::transform::proto::Rigid3d* mutable_local_pose();
  void set_allocated_local_pose(::cartographer::transform::proto::Rigid3d* local_pose);

  // int64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.TrajectoryNodePose.ConstantPoseData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::transform::proto::Rigid3d* local_pose_;
  ::google::protobuf::int64 timestamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrajectoryNodePose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.TrajectoryNodePose) */ {
 public:
  TrajectoryNodePose();
  virtual ~TrajectoryNodePose();

  TrajectoryNodePose(const TrajectoryNodePose& from);

  inline TrajectoryNodePose& operator=(const TrajectoryNodePose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrajectoryNodePose(TrajectoryNodePose&& from) noexcept
    : TrajectoryNodePose() {
    *this = ::std::move(from);
  }

  inline TrajectoryNodePose& operator=(TrajectoryNodePose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrajectoryNodePose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrajectoryNodePose* internal_default_instance() {
    return reinterpret_cast<const TrajectoryNodePose*>(
               &_TrajectoryNodePose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(TrajectoryNodePose* other);
  friend void swap(TrajectoryNodePose& a, TrajectoryNodePose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrajectoryNodePose* New() const final {
    return CreateMaybeMessage<TrajectoryNodePose>(NULL);
  }

  TrajectoryNodePose* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrajectoryNodePose>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrajectoryNodePose& from);
  void MergeFrom(const TrajectoryNodePose& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrajectoryNodePose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TrajectoryNodePose_ConstantPoseData ConstantPoseData;

  // accessors -------------------------------------------------------

  // .cartographer.mapping.proto.NodeId node_id = 1;
  bool has_node_id() const;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  private:
  const ::cartographer::mapping::proto::NodeId& _internal_node_id() const;
  public:
  const ::cartographer::mapping::proto::NodeId& node_id() const;
  ::cartographer::mapping::proto::NodeId* release_node_id();
  ::cartographer::mapping::proto::NodeId* mutable_node_id();
  void set_allocated_node_id(::cartographer::mapping::proto::NodeId* node_id);

  // .cartographer.transform.proto.Rigid3d global_pose = 2;
  bool has_global_pose() const;
  void clear_global_pose();
  static const int kGlobalPoseFieldNumber = 2;
  private:
  const ::cartographer::transform::proto::Rigid3d& _internal_global_pose() const;
  public:
  const ::cartographer::transform::proto::Rigid3d& global_pose() const;
  ::cartographer::transform::proto::Rigid3d* release_global_pose();
  ::cartographer::transform::proto::Rigid3d* mutable_global_pose();
  void set_allocated_global_pose(::cartographer::transform::proto::Rigid3d* global_pose);

  // .cartographer.cloud.proto.TrajectoryNodePose.ConstantPoseData constant_pose_data = 3;
  bool has_constant_pose_data() const;
  void clear_constant_pose_data();
  static const int kConstantPoseDataFieldNumber = 3;
  private:
  const ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData& _internal_constant_pose_data() const;
  public:
  const ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData& constant_pose_data() const;
  ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData* release_constant_pose_data();
  ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData* mutable_constant_pose_data();
  void set_allocated_constant_pose_data(::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData* constant_pose_data);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.TrajectoryNodePose)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::mapping::proto::NodeId* node_id_;
  ::cartographer::transform::proto::Rigid3d* global_pose_;
  ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData* constant_pose_data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetTrajectoryNodePosesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.GetTrajectoryNodePosesResponse) */ {
 public:
  GetTrajectoryNodePosesResponse();
  virtual ~GetTrajectoryNodePosesResponse();

  GetTrajectoryNodePosesResponse(const GetTrajectoryNodePosesResponse& from);

  inline GetTrajectoryNodePosesResponse& operator=(const GetTrajectoryNodePosesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTrajectoryNodePosesResponse(GetTrajectoryNodePosesResponse&& from) noexcept
    : GetTrajectoryNodePosesResponse() {
    *this = ::std::move(from);
  }

  inline GetTrajectoryNodePosesResponse& operator=(GetTrajectoryNodePosesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTrajectoryNodePosesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTrajectoryNodePosesResponse* internal_default_instance() {
    return reinterpret_cast<const GetTrajectoryNodePosesResponse*>(
               &_GetTrajectoryNodePosesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(GetTrajectoryNodePosesResponse* other);
  friend void swap(GetTrajectoryNodePosesResponse& a, GetTrajectoryNodePosesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTrajectoryNodePosesResponse* New() const final {
    return CreateMaybeMessage<GetTrajectoryNodePosesResponse>(NULL);
  }

  GetTrajectoryNodePosesResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetTrajectoryNodePosesResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetTrajectoryNodePosesResponse& from);
  void MergeFrom(const GetTrajectoryNodePosesResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTrajectoryNodePosesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .cartographer.cloud.proto.TrajectoryNodePose node_poses = 1;
  int node_poses_size() const;
  void clear_node_poses();
  static const int kNodePosesFieldNumber = 1;
  ::cartographer::cloud::proto::TrajectoryNodePose* mutable_node_poses(int index);
  ::google::protobuf::RepeatedPtrField< ::cartographer::cloud::proto::TrajectoryNodePose >*
      mutable_node_poses();
  const ::cartographer::cloud::proto::TrajectoryNodePose& node_poses(int index) const;
  ::cartographer::cloud::proto::TrajectoryNodePose* add_node_poses();
  const ::google::protobuf::RepeatedPtrField< ::cartographer::cloud::proto::TrajectoryNodePose >&
      node_poses() const;

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.GetTrajectoryNodePosesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::cartographer::cloud::proto::TrajectoryNodePose > node_poses_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse, 
    ::google::protobuf::int32, ::cartographer::cloud::proto::TrajectoryState,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_ENUM,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse, 
    ::google::protobuf::int32, ::cartographer::cloud::proto::TrajectoryState,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_ENUM,
    0 > SuperType;
  GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse();
  GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse& other);
  static const GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse*>(&_GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class GetTrajectoryStatesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.GetTrajectoryStatesResponse) */ {
 public:
  GetTrajectoryStatesResponse();
  virtual ~GetTrajectoryStatesResponse();

  GetTrajectoryStatesResponse(const GetTrajectoryStatesResponse& from);

  inline GetTrajectoryStatesResponse& operator=(const GetTrajectoryStatesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTrajectoryStatesResponse(GetTrajectoryStatesResponse&& from) noexcept
    : GetTrajectoryStatesResponse() {
    *this = ::std::move(from);
  }

  inline GetTrajectoryStatesResponse& operator=(GetTrajectoryStatesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTrajectoryStatesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTrajectoryStatesResponse* internal_default_instance() {
    return reinterpret_cast<const GetTrajectoryStatesResponse*>(
               &_GetTrajectoryStatesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(GetTrajectoryStatesResponse* other);
  friend void swap(GetTrajectoryStatesResponse& a, GetTrajectoryStatesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTrajectoryStatesResponse* New() const final {
    return CreateMaybeMessage<GetTrajectoryStatesResponse>(NULL);
  }

  GetTrajectoryStatesResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetTrajectoryStatesResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetTrajectoryStatesResponse& from);
  void MergeFrom(const GetTrajectoryStatesResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTrajectoryStatesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<int32, .cartographer.cloud.proto.TrajectoryState> trajectories_state = 1;
  int trajectories_state_size() const;
  void clear_trajectories_state();
  static const int kTrajectoriesStateFieldNumber = 1;
  const ::google::protobuf::Map< ::google::protobuf::int32, ::cartographer::cloud::proto::TrajectoryState >&
      trajectories_state() const;
  ::google::protobuf::Map< ::google::protobuf::int32, ::cartographer::cloud::proto::TrajectoryState >*
      mutable_trajectories_state();

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.GetTrajectoryStatesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse,
      ::google::protobuf::int32, ::cartographer::cloud::proto::TrajectoryState,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_ENUM,
      0 > trajectories_state_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetLandmarkPosesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.GetLandmarkPosesResponse) */ {
 public:
  GetLandmarkPosesResponse();
  virtual ~GetLandmarkPosesResponse();

  GetLandmarkPosesResponse(const GetLandmarkPosesResponse& from);

  inline GetLandmarkPosesResponse& operator=(const GetLandmarkPosesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetLandmarkPosesResponse(GetLandmarkPosesResponse&& from) noexcept
    : GetLandmarkPosesResponse() {
    *this = ::std::move(from);
  }

  inline GetLandmarkPosesResponse& operator=(GetLandmarkPosesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLandmarkPosesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetLandmarkPosesResponse* internal_default_instance() {
    return reinterpret_cast<const GetLandmarkPosesResponse*>(
               &_GetLandmarkPosesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(GetLandmarkPosesResponse* other);
  friend void swap(GetLandmarkPosesResponse& a, GetLandmarkPosesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetLandmarkPosesResponse* New() const final {
    return CreateMaybeMessage<GetLandmarkPosesResponse>(NULL);
  }

  GetLandmarkPosesResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetLandmarkPosesResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetLandmarkPosesResponse& from);
  void MergeFrom(const GetLandmarkPosesResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLandmarkPosesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .cartographer.mapping.proto.PoseGraph.LandmarkPose landmark_poses = 1;
  int landmark_poses_size() const;
  void clear_landmark_poses();
  static const int kLandmarkPosesFieldNumber = 1;
  ::cartographer::mapping::proto::PoseGraph_LandmarkPose* mutable_landmark_poses(int index);
  ::google::protobuf::RepeatedPtrField< ::cartographer::mapping::proto::PoseGraph_LandmarkPose >*
      mutable_landmark_poses();
  const ::cartographer::mapping::proto::PoseGraph_LandmarkPose& landmark_poses(int index) const;
  ::cartographer::mapping::proto::PoseGraph_LandmarkPose* add_landmark_poses();
  const ::google::protobuf::RepeatedPtrField< ::cartographer::mapping::proto::PoseGraph_LandmarkPose >&
      landmark_poses() const;

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.GetLandmarkPosesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::cartographer::mapping::proto::PoseGraph_LandmarkPose > landmark_poses_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetLandmarkPoseRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.SetLandmarkPoseRequest) */ {
 public:
  SetLandmarkPoseRequest();
  virtual ~SetLandmarkPoseRequest();

  SetLandmarkPoseRequest(const SetLandmarkPoseRequest& from);

  inline SetLandmarkPoseRequest& operator=(const SetLandmarkPoseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetLandmarkPoseRequest(SetLandmarkPoseRequest&& from) noexcept
    : SetLandmarkPoseRequest() {
    *this = ::std::move(from);
  }

  inline SetLandmarkPoseRequest& operator=(SetLandmarkPoseRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetLandmarkPoseRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetLandmarkPoseRequest* internal_default_instance() {
    return reinterpret_cast<const SetLandmarkPoseRequest*>(
               &_SetLandmarkPoseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(SetLandmarkPoseRequest* other);
  friend void swap(SetLandmarkPoseRequest& a, SetLandmarkPoseRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetLandmarkPoseRequest* New() const final {
    return CreateMaybeMessage<SetLandmarkPoseRequest>(NULL);
  }

  SetLandmarkPoseRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetLandmarkPoseRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetLandmarkPoseRequest& from);
  void MergeFrom(const SetLandmarkPoseRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetLandmarkPoseRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cartographer.mapping.proto.PoseGraph.LandmarkPose landmark_pose = 1;
  bool has_landmark_pose() const;
  void clear_landmark_pose();
  static const int kLandmarkPoseFieldNumber = 1;
  private:
  const ::cartographer::mapping::proto::PoseGraph_LandmarkPose& _internal_landmark_pose() const;
  public:
  const ::cartographer::mapping::proto::PoseGraph_LandmarkPose& landmark_pose() const;
  ::cartographer::mapping::proto::PoseGraph_LandmarkPose* release_landmark_pose();
  ::cartographer::mapping::proto::PoseGraph_LandmarkPose* mutable_landmark_pose();
  void set_allocated_landmark_pose(::cartographer::mapping::proto::PoseGraph_LandmarkPose* landmark_pose);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.SetLandmarkPoseRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::mapping::proto::PoseGraph_LandmarkPose* landmark_pose_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SubmapPose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.SubmapPose) */ {
 public:
  SubmapPose();
  virtual ~SubmapPose();

  SubmapPose(const SubmapPose& from);

  inline SubmapPose& operator=(const SubmapPose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SubmapPose(SubmapPose&& from) noexcept
    : SubmapPose() {
    *this = ::std::move(from);
  }

  inline SubmapPose& operator=(SubmapPose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SubmapPose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubmapPose* internal_default_instance() {
    return reinterpret_cast<const SubmapPose*>(
               &_SubmapPose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(SubmapPose* other);
  friend void swap(SubmapPose& a, SubmapPose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubmapPose* New() const final {
    return CreateMaybeMessage<SubmapPose>(NULL);
  }

  SubmapPose* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SubmapPose>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SubmapPose& from);
  void MergeFrom(const SubmapPose& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmapPose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cartographer.mapping.proto.SubmapId submap_id = 1;
  bool has_submap_id() const;
  void clear_submap_id();
  static const int kSubmapIdFieldNumber = 1;
  private:
  const ::cartographer::mapping::proto::SubmapId& _internal_submap_id() const;
  public:
  const ::cartographer::mapping::proto::SubmapId& submap_id() const;
  ::cartographer::mapping::proto::SubmapId* release_submap_id();
  ::cartographer::mapping::proto::SubmapId* mutable_submap_id();
  void set_allocated_submap_id(::cartographer::mapping::proto::SubmapId* submap_id);

  // .cartographer.transform.proto.Rigid3d global_pose = 3;
  bool has_global_pose() const;
  void clear_global_pose();
  static const int kGlobalPoseFieldNumber = 3;
  private:
  const ::cartographer::transform::proto::Rigid3d& _internal_global_pose() const;
  public:
  const ::cartographer::transform::proto::Rigid3d& global_pose() const;
  ::cartographer::transform::proto::Rigid3d* release_global_pose();
  ::cartographer::transform::proto::Rigid3d* mutable_global_pose();
  void set_allocated_global_pose(::cartographer::transform::proto::Rigid3d* global_pose);

  // int32 submap_version = 2;
  void clear_submap_version();
  static const int kSubmapVersionFieldNumber = 2;
  ::google::protobuf::int32 submap_version() const;
  void set_submap_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.SubmapPose)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::mapping::proto::SubmapId* submap_id_;
  ::cartographer::transform::proto::Rigid3d* global_pose_;
  ::google::protobuf::int32 submap_version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetAllSubmapPosesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.GetAllSubmapPosesResponse) */ {
 public:
  GetAllSubmapPosesResponse();
  virtual ~GetAllSubmapPosesResponse();

  GetAllSubmapPosesResponse(const GetAllSubmapPosesResponse& from);

  inline GetAllSubmapPosesResponse& operator=(const GetAllSubmapPosesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetAllSubmapPosesResponse(GetAllSubmapPosesResponse&& from) noexcept
    : GetAllSubmapPosesResponse() {
    *this = ::std::move(from);
  }

  inline GetAllSubmapPosesResponse& operator=(GetAllSubmapPosesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAllSubmapPosesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetAllSubmapPosesResponse* internal_default_instance() {
    return reinterpret_cast<const GetAllSubmapPosesResponse*>(
               &_GetAllSubmapPosesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(GetAllSubmapPosesResponse* other);
  friend void swap(GetAllSubmapPosesResponse& a, GetAllSubmapPosesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAllSubmapPosesResponse* New() const final {
    return CreateMaybeMessage<GetAllSubmapPosesResponse>(NULL);
  }

  GetAllSubmapPosesResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetAllSubmapPosesResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetAllSubmapPosesResponse& from);
  void MergeFrom(const GetAllSubmapPosesResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAllSubmapPosesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .cartographer.cloud.proto.SubmapPose submap_poses = 1;
  int submap_poses_size() const;
  void clear_submap_poses();
  static const int kSubmapPosesFieldNumber = 1;
  ::cartographer::cloud::proto::SubmapPose* mutable_submap_poses(int index);
  ::google::protobuf::RepeatedPtrField< ::cartographer::cloud::proto::SubmapPose >*
      mutable_submap_poses();
  const ::cartographer::cloud::proto::SubmapPose& submap_poses(int index) const;
  ::cartographer::cloud::proto::SubmapPose* add_submap_poses();
  const ::google::protobuf::RepeatedPtrField< ::cartographer::cloud::proto::SubmapPose >&
      submap_poses() const;

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.GetAllSubmapPosesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::cartographer::cloud::proto::SubmapPose > submap_poses_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetLocalToGlobalTransformRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.GetLocalToGlobalTransformRequest) */ {
 public:
  GetLocalToGlobalTransformRequest();
  virtual ~GetLocalToGlobalTransformRequest();

  GetLocalToGlobalTransformRequest(const GetLocalToGlobalTransformRequest& from);

  inline GetLocalToGlobalTransformRequest& operator=(const GetLocalToGlobalTransformRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetLocalToGlobalTransformRequest(GetLocalToGlobalTransformRequest&& from) noexcept
    : GetLocalToGlobalTransformRequest() {
    *this = ::std::move(from);
  }

  inline GetLocalToGlobalTransformRequest& operator=(GetLocalToGlobalTransformRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLocalToGlobalTransformRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetLocalToGlobalTransformRequest* internal_default_instance() {
    return reinterpret_cast<const GetLocalToGlobalTransformRequest*>(
               &_GetLocalToGlobalTransformRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(GetLocalToGlobalTransformRequest* other);
  friend void swap(GetLocalToGlobalTransformRequest& a, GetLocalToGlobalTransformRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetLocalToGlobalTransformRequest* New() const final {
    return CreateMaybeMessage<GetLocalToGlobalTransformRequest>(NULL);
  }

  GetLocalToGlobalTransformRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetLocalToGlobalTransformRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetLocalToGlobalTransformRequest& from);
  void MergeFrom(const GetLocalToGlobalTransformRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLocalToGlobalTransformRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 trajectory_id = 1;
  void clear_trajectory_id();
  static const int kTrajectoryIdFieldNumber = 1;
  ::google::protobuf::int32 trajectory_id() const;
  void set_trajectory_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.GetLocalToGlobalTransformRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 trajectory_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetLocalToGlobalTransformResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.GetLocalToGlobalTransformResponse) */ {
 public:
  GetLocalToGlobalTransformResponse();
  virtual ~GetLocalToGlobalTransformResponse();

  GetLocalToGlobalTransformResponse(const GetLocalToGlobalTransformResponse& from);

  inline GetLocalToGlobalTransformResponse& operator=(const GetLocalToGlobalTransformResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetLocalToGlobalTransformResponse(GetLocalToGlobalTransformResponse&& from) noexcept
    : GetLocalToGlobalTransformResponse() {
    *this = ::std::move(from);
  }

  inline GetLocalToGlobalTransformResponse& operator=(GetLocalToGlobalTransformResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLocalToGlobalTransformResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetLocalToGlobalTransformResponse* internal_default_instance() {
    return reinterpret_cast<const GetLocalToGlobalTransformResponse*>(
               &_GetLocalToGlobalTransformResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(GetLocalToGlobalTransformResponse* other);
  friend void swap(GetLocalToGlobalTransformResponse& a, GetLocalToGlobalTransformResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetLocalToGlobalTransformResponse* New() const final {
    return CreateMaybeMessage<GetLocalToGlobalTransformResponse>(NULL);
  }

  GetLocalToGlobalTransformResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetLocalToGlobalTransformResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetLocalToGlobalTransformResponse& from);
  void MergeFrom(const GetLocalToGlobalTransformResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLocalToGlobalTransformResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cartographer.transform.proto.Rigid3d local_to_global = 1;
  bool has_local_to_global() const;
  void clear_local_to_global();
  static const int kLocalToGlobalFieldNumber = 1;
  private:
  const ::cartographer::transform::proto::Rigid3d& _internal_local_to_global() const;
  public:
  const ::cartographer::transform::proto::Rigid3d& local_to_global() const;
  ::cartographer::transform::proto::Rigid3d* release_local_to_global();
  ::cartographer::transform::proto::Rigid3d* mutable_local_to_global();
  void set_allocated_local_to_global(::cartographer::transform::proto::Rigid3d* local_to_global);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.GetLocalToGlobalTransformResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::transform::proto::Rigid3d* local_to_global_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetConstraintsResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.GetConstraintsResponse) */ {
 public:
  GetConstraintsResponse();
  virtual ~GetConstraintsResponse();

  GetConstraintsResponse(const GetConstraintsResponse& from);

  inline GetConstraintsResponse& operator=(const GetConstraintsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetConstraintsResponse(GetConstraintsResponse&& from) noexcept
    : GetConstraintsResponse() {
    *this = ::std::move(from);
  }

  inline GetConstraintsResponse& operator=(GetConstraintsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetConstraintsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetConstraintsResponse* internal_default_instance() {
    return reinterpret_cast<const GetConstraintsResponse*>(
               &_GetConstraintsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(GetConstraintsResponse* other);
  friend void swap(GetConstraintsResponse& a, GetConstraintsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetConstraintsResponse* New() const final {
    return CreateMaybeMessage<GetConstraintsResponse>(NULL);
  }

  GetConstraintsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetConstraintsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetConstraintsResponse& from);
  void MergeFrom(const GetConstraintsResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetConstraintsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .cartographer.mapping.proto.PoseGraph.Constraint constraints = 1;
  int constraints_size() const;
  void clear_constraints();
  static const int kConstraintsFieldNumber = 1;
  ::cartographer::mapping::proto::PoseGraph_Constraint* mutable_constraints(int index);
  ::google::protobuf::RepeatedPtrField< ::cartographer::mapping::proto::PoseGraph_Constraint >*
      mutable_constraints();
  const ::cartographer::mapping::proto::PoseGraph_Constraint& constraints(int index) const;
  ::cartographer::mapping::proto::PoseGraph_Constraint* add_constraints();
  const ::google::protobuf::RepeatedPtrField< ::cartographer::mapping::proto::PoseGraph_Constraint >&
      constraints() const;

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.GetConstraintsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::cartographer::mapping::proto::PoseGraph_Constraint > constraints_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteStateResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.WriteStateResponse) */ {
 public:
  WriteStateResponse();
  virtual ~WriteStateResponse();

  WriteStateResponse(const WriteStateResponse& from);

  inline WriteStateResponse& operator=(const WriteStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteStateResponse(WriteStateResponse&& from) noexcept
    : WriteStateResponse() {
    *this = ::std::move(from);
  }

  inline WriteStateResponse& operator=(WriteStateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteStateResponse& default_instance();

  enum StateChunkCase {
    kHeader = 1,
    kSerializedData = 2,
    STATE_CHUNK_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteStateResponse* internal_default_instance() {
    return reinterpret_cast<const WriteStateResponse*>(
               &_WriteStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(WriteStateResponse* other);
  friend void swap(WriteStateResponse& a, WriteStateResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteStateResponse* New() const final {
    return CreateMaybeMessage<WriteStateResponse>(NULL);
  }

  WriteStateResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WriteStateResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WriteStateResponse& from);
  void MergeFrom(const WriteStateResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteStateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cartographer.mapping.proto.SerializationHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::cartographer::mapping::proto::SerializationHeader& _internal_header() const;
  public:
  const ::cartographer::mapping::proto::SerializationHeader& header() const;
  ::cartographer::mapping::proto::SerializationHeader* release_header();
  ::cartographer::mapping::proto::SerializationHeader* mutable_header();
  void set_allocated_header(::cartographer::mapping::proto::SerializationHeader* header);

  // .cartographer.mapping.proto.SerializedData serialized_data = 2;
  bool has_serialized_data() const;
  void clear_serialized_data();
  static const int kSerializedDataFieldNumber = 2;
  private:
  const ::cartographer::mapping::proto::SerializedData& _internal_serialized_data() const;
  public:
  const ::cartographer::mapping::proto::SerializedData& serialized_data() const;
  ::cartographer::mapping::proto::SerializedData* release_serialized_data();
  ::cartographer::mapping::proto::SerializedData* mutable_serialized_data();
  void set_allocated_serialized_data(::cartographer::mapping::proto::SerializedData* serialized_data);

  void clear_state_chunk();
  StateChunkCase state_chunk_case() const;
  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.WriteStateResponse)
 private:
  void set_has_header();
  void set_has_serialized_data();

  inline bool has_state_chunk() const;
  inline void clear_has_state_chunk();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union StateChunkUnion {
    StateChunkUnion() {}
    ::cartographer::mapping::proto::SerializationHeader* header_;
    ::cartographer::mapping::proto::SerializedData* serialized_data_;
  } state_chunk_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteStateToFileRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.WriteStateToFileRequest) */ {
 public:
  WriteStateToFileRequest();
  virtual ~WriteStateToFileRequest();

  WriteStateToFileRequest(const WriteStateToFileRequest& from);

  inline WriteStateToFileRequest& operator=(const WriteStateToFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteStateToFileRequest(WriteStateToFileRequest&& from) noexcept
    : WriteStateToFileRequest() {
    *this = ::std::move(from);
  }

  inline WriteStateToFileRequest& operator=(WriteStateToFileRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteStateToFileRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteStateToFileRequest* internal_default_instance() {
    return reinterpret_cast<const WriteStateToFileRequest*>(
               &_WriteStateToFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(WriteStateToFileRequest* other);
  friend void swap(WriteStateToFileRequest& a, WriteStateToFileRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteStateToFileRequest* New() const final {
    return CreateMaybeMessage<WriteStateToFileRequest>(NULL);
  }

  WriteStateToFileRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WriteStateToFileRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WriteStateToFileRequest& from);
  void MergeFrom(const WriteStateToFileRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteStateToFileRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string filename = 1;
  void clear_filename();
  static const int kFilenameFieldNumber = 1;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  #if LANG_CXX11
  void set_filename(::std::string&& value);
  #endif
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.WriteStateToFileRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteStateToFileResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.WriteStateToFileResponse) */ {
 public:
  WriteStateToFileResponse();
  virtual ~WriteStateToFileResponse();

  WriteStateToFileResponse(const WriteStateToFileResponse& from);

  inline WriteStateToFileResponse& operator=(const WriteStateToFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteStateToFileResponse(WriteStateToFileResponse&& from) noexcept
    : WriteStateToFileResponse() {
    *this = ::std::move(from);
  }

  inline WriteStateToFileResponse& operator=(WriteStateToFileResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteStateToFileResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteStateToFileResponse* internal_default_instance() {
    return reinterpret_cast<const WriteStateToFileResponse*>(
               &_WriteStateToFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(WriteStateToFileResponse* other);
  friend void swap(WriteStateToFileResponse& a, WriteStateToFileResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteStateToFileResponse* New() const final {
    return CreateMaybeMessage<WriteStateToFileResponse>(NULL);
  }

  WriteStateToFileResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WriteStateToFileResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WriteStateToFileResponse& from);
  void MergeFrom(const WriteStateToFileResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteStateToFileResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool success = 1;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.WriteStateToFileResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool success_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IsTrajectoryFinishedRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.IsTrajectoryFinishedRequest) */ {
 public:
  IsTrajectoryFinishedRequest();
  virtual ~IsTrajectoryFinishedRequest();

  IsTrajectoryFinishedRequest(const IsTrajectoryFinishedRequest& from);

  inline IsTrajectoryFinishedRequest& operator=(const IsTrajectoryFinishedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IsTrajectoryFinishedRequest(IsTrajectoryFinishedRequest&& from) noexcept
    : IsTrajectoryFinishedRequest() {
    *this = ::std::move(from);
  }

  inline IsTrajectoryFinishedRequest& operator=(IsTrajectoryFinishedRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IsTrajectoryFinishedRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IsTrajectoryFinishedRequest* internal_default_instance() {
    return reinterpret_cast<const IsTrajectoryFinishedRequest*>(
               &_IsTrajectoryFinishedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(IsTrajectoryFinishedRequest* other);
  friend void swap(IsTrajectoryFinishedRequest& a, IsTrajectoryFinishedRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IsTrajectoryFinishedRequest* New() const final {
    return CreateMaybeMessage<IsTrajectoryFinishedRequest>(NULL);
  }

  IsTrajectoryFinishedRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IsTrajectoryFinishedRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IsTrajectoryFinishedRequest& from);
  void MergeFrom(const IsTrajectoryFinishedRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsTrajectoryFinishedRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 trajectory_id = 1;
  void clear_trajectory_id();
  static const int kTrajectoryIdFieldNumber = 1;
  ::google::protobuf::int32 trajectory_id() const;
  void set_trajectory_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.IsTrajectoryFinishedRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 trajectory_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IsTrajectoryFinishedResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.IsTrajectoryFinishedResponse) */ {
 public:
  IsTrajectoryFinishedResponse();
  virtual ~IsTrajectoryFinishedResponse();

  IsTrajectoryFinishedResponse(const IsTrajectoryFinishedResponse& from);

  inline IsTrajectoryFinishedResponse& operator=(const IsTrajectoryFinishedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IsTrajectoryFinishedResponse(IsTrajectoryFinishedResponse&& from) noexcept
    : IsTrajectoryFinishedResponse() {
    *this = ::std::move(from);
  }

  inline IsTrajectoryFinishedResponse& operator=(IsTrajectoryFinishedResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IsTrajectoryFinishedResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IsTrajectoryFinishedResponse* internal_default_instance() {
    return reinterpret_cast<const IsTrajectoryFinishedResponse*>(
               &_IsTrajectoryFinishedResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(IsTrajectoryFinishedResponse* other);
  friend void swap(IsTrajectoryFinishedResponse& a, IsTrajectoryFinishedResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IsTrajectoryFinishedResponse* New() const final {
    return CreateMaybeMessage<IsTrajectoryFinishedResponse>(NULL);
  }

  IsTrajectoryFinishedResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IsTrajectoryFinishedResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IsTrajectoryFinishedResponse& from);
  void MergeFrom(const IsTrajectoryFinishedResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsTrajectoryFinishedResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool is_finished = 1;
  void clear_is_finished();
  static const int kIsFinishedFieldNumber = 1;
  bool is_finished() const;
  void set_is_finished(bool value);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.IsTrajectoryFinishedResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool is_finished_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IsTrajectoryFrozenRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.IsTrajectoryFrozenRequest) */ {
 public:
  IsTrajectoryFrozenRequest();
  virtual ~IsTrajectoryFrozenRequest();

  IsTrajectoryFrozenRequest(const IsTrajectoryFrozenRequest& from);

  inline IsTrajectoryFrozenRequest& operator=(const IsTrajectoryFrozenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IsTrajectoryFrozenRequest(IsTrajectoryFrozenRequest&& from) noexcept
    : IsTrajectoryFrozenRequest() {
    *this = ::std::move(from);
  }

  inline IsTrajectoryFrozenRequest& operator=(IsTrajectoryFrozenRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IsTrajectoryFrozenRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IsTrajectoryFrozenRequest* internal_default_instance() {
    return reinterpret_cast<const IsTrajectoryFrozenRequest*>(
               &_IsTrajectoryFrozenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  void Swap(IsTrajectoryFrozenRequest* other);
  friend void swap(IsTrajectoryFrozenRequest& a, IsTrajectoryFrozenRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IsTrajectoryFrozenRequest* New() const final {
    return CreateMaybeMessage<IsTrajectoryFrozenRequest>(NULL);
  }

  IsTrajectoryFrozenRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IsTrajectoryFrozenRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IsTrajectoryFrozenRequest& from);
  void MergeFrom(const IsTrajectoryFrozenRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsTrajectoryFrozenRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 trajectory_id = 1;
  void clear_trajectory_id();
  static const int kTrajectoryIdFieldNumber = 1;
  ::google::protobuf::int32 trajectory_id() const;
  void set_trajectory_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.IsTrajectoryFrozenRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 trajectory_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IsTrajectoryFrozenResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.IsTrajectoryFrozenResponse) */ {
 public:
  IsTrajectoryFrozenResponse();
  virtual ~IsTrajectoryFrozenResponse();

  IsTrajectoryFrozenResponse(const IsTrajectoryFrozenResponse& from);

  inline IsTrajectoryFrozenResponse& operator=(const IsTrajectoryFrozenResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IsTrajectoryFrozenResponse(IsTrajectoryFrozenResponse&& from) noexcept
    : IsTrajectoryFrozenResponse() {
    *this = ::std::move(from);
  }

  inline IsTrajectoryFrozenResponse& operator=(IsTrajectoryFrozenResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IsTrajectoryFrozenResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IsTrajectoryFrozenResponse* internal_default_instance() {
    return reinterpret_cast<const IsTrajectoryFrozenResponse*>(
               &_IsTrajectoryFrozenResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  void Swap(IsTrajectoryFrozenResponse* other);
  friend void swap(IsTrajectoryFrozenResponse& a, IsTrajectoryFrozenResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IsTrajectoryFrozenResponse* New() const final {
    return CreateMaybeMessage<IsTrajectoryFrozenResponse>(NULL);
  }

  IsTrajectoryFrozenResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IsTrajectoryFrozenResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IsTrajectoryFrozenResponse& from);
  void MergeFrom(const IsTrajectoryFrozenResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsTrajectoryFrozenResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool is_frozen = 1;
  void clear_is_frozen();
  static const int kIsFrozenFieldNumber = 1;
  bool is_frozen() const;
  void set_is_frozen(bool value);

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.IsTrajectoryFrozenResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool is_frozen_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SensorId

// string id = 1;
inline void SensorId::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SensorId::id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SensorId.id)
  return id_.GetNoArena();
}
inline void SensorId::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.SensorId.id)
}
#if LANG_CXX11
inline void SensorId::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.SensorId.id)
}
#endif
inline void SensorId::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.SensorId.id)
}
inline void SensorId::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.SensorId.id)
}
inline ::std::string* SensorId::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.SensorId.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SensorId::release_id() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.SensorId.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SensorId::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.SensorId.id)
}

// .cartographer.cloud.proto.SensorType type = 2;
inline void SensorId::clear_type() {
  type_ = 0;
}
inline ::cartographer::cloud::proto::SensorType SensorId::type() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SensorId.type)
  return static_cast< ::cartographer::cloud::proto::SensorType >(type_);
}
inline void SensorId::set_type(::cartographer::cloud::proto::SensorType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.SensorId.type)
}

// -------------------------------------------------------------------

// AddTrajectoryRequest

// repeated .cartographer.cloud.proto.SensorId expected_sensor_ids = 3;
inline int AddTrajectoryRequest::expected_sensor_ids_size() const {
  return expected_sensor_ids_.size();
}
inline void AddTrajectoryRequest::clear_expected_sensor_ids() {
  expected_sensor_ids_.Clear();
}
inline ::cartographer::cloud::proto::SensorId* AddTrajectoryRequest::mutable_expected_sensor_ids(int index) {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddTrajectoryRequest.expected_sensor_ids)
  return expected_sensor_ids_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::cartographer::cloud::proto::SensorId >*
AddTrajectoryRequest::mutable_expected_sensor_ids() {
  // @@protoc_insertion_point(field_mutable_list:cartographer.cloud.proto.AddTrajectoryRequest.expected_sensor_ids)
  return &expected_sensor_ids_;
}
inline const ::cartographer::cloud::proto::SensorId& AddTrajectoryRequest::expected_sensor_ids(int index) const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddTrajectoryRequest.expected_sensor_ids)
  return expected_sensor_ids_.Get(index);
}
inline ::cartographer::cloud::proto::SensorId* AddTrajectoryRequest::add_expected_sensor_ids() {
  // @@protoc_insertion_point(field_add:cartographer.cloud.proto.AddTrajectoryRequest.expected_sensor_ids)
  return expected_sensor_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cartographer::cloud::proto::SensorId >&
AddTrajectoryRequest::expected_sensor_ids() const {
  // @@protoc_insertion_point(field_list:cartographer.cloud.proto.AddTrajectoryRequest.expected_sensor_ids)
  return expected_sensor_ids_;
}

// .cartographer.mapping.proto.TrajectoryBuilderOptions trajectory_builder_options = 2;
inline bool AddTrajectoryRequest::has_trajectory_builder_options() const {
  return this != internal_default_instance() && trajectory_builder_options_ != NULL;
}
inline const ::cartographer::mapping::proto::TrajectoryBuilderOptions& AddTrajectoryRequest::_internal_trajectory_builder_options() const {
  return *trajectory_builder_options_;
}
inline const ::cartographer::mapping::proto::TrajectoryBuilderOptions& AddTrajectoryRequest::trajectory_builder_options() const {
  const ::cartographer::mapping::proto::TrajectoryBuilderOptions* p = trajectory_builder_options_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddTrajectoryRequest.trajectory_builder_options)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::mapping::proto::TrajectoryBuilderOptions*>(
      &::cartographer::mapping::proto::_TrajectoryBuilderOptions_default_instance_);
}
inline ::cartographer::mapping::proto::TrajectoryBuilderOptions* AddTrajectoryRequest::release_trajectory_builder_options() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.AddTrajectoryRequest.trajectory_builder_options)
  
  ::cartographer::mapping::proto::TrajectoryBuilderOptions* temp = trajectory_builder_options_;
  trajectory_builder_options_ = NULL;
  return temp;
}
inline ::cartographer::mapping::proto::TrajectoryBuilderOptions* AddTrajectoryRequest::mutable_trajectory_builder_options() {
  
  if (trajectory_builder_options_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::mapping::proto::TrajectoryBuilderOptions>(GetArenaNoVirtual());
    trajectory_builder_options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddTrajectoryRequest.trajectory_builder_options)
  return trajectory_builder_options_;
}
inline void AddTrajectoryRequest::set_allocated_trajectory_builder_options(::cartographer::mapping::proto::TrajectoryBuilderOptions* trajectory_builder_options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(trajectory_builder_options_);
  }
  if (trajectory_builder_options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      trajectory_builder_options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trajectory_builder_options, submessage_arena);
    }
    
  } else {
    
  }
  trajectory_builder_options_ = trajectory_builder_options;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.AddTrajectoryRequest.trajectory_builder_options)
}

// string client_id = 4;
inline void AddTrajectoryRequest::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AddTrajectoryRequest::client_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddTrajectoryRequest.client_id)
  return client_id_.GetNoArena();
}
inline void AddTrajectoryRequest::set_client_id(const ::std::string& value) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.AddTrajectoryRequest.client_id)
}
#if LANG_CXX11
inline void AddTrajectoryRequest::set_client_id(::std::string&& value) {
  
  client_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.AddTrajectoryRequest.client_id)
}
#endif
inline void AddTrajectoryRequest::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.AddTrajectoryRequest.client_id)
}
inline void AddTrajectoryRequest::set_client_id(const char* value, size_t size) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.AddTrajectoryRequest.client_id)
}
inline ::std::string* AddTrajectoryRequest::mutable_client_id() {
  
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddTrajectoryRequest.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AddTrajectoryRequest::release_client_id() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.AddTrajectoryRequest.client_id)
  
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AddTrajectoryRequest::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    
  } else {
    
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.AddTrajectoryRequest.client_id)
}

// -------------------------------------------------------------------

// SensorMetadata

// int32 trajectory_id = 1;
inline void SensorMetadata::clear_trajectory_id() {
  trajectory_id_ = 0;
}
inline ::google::protobuf::int32 SensorMetadata::trajectory_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SensorMetadata.trajectory_id)
  return trajectory_id_;
}
inline void SensorMetadata::set_trajectory_id(::google::protobuf::int32 value) {
  
  trajectory_id_ = value;
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.SensorMetadata.trajectory_id)
}

// string sensor_id = 2;
inline void SensorMetadata::clear_sensor_id() {
  sensor_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SensorMetadata::sensor_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SensorMetadata.sensor_id)
  return sensor_id_.GetNoArena();
}
inline void SensorMetadata::set_sensor_id(const ::std::string& value) {
  
  sensor_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.SensorMetadata.sensor_id)
}
#if LANG_CXX11
inline void SensorMetadata::set_sensor_id(::std::string&& value) {
  
  sensor_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.SensorMetadata.sensor_id)
}
#endif
inline void SensorMetadata::set_sensor_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sensor_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.SensorMetadata.sensor_id)
}
inline void SensorMetadata::set_sensor_id(const char* value, size_t size) {
  
  sensor_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.SensorMetadata.sensor_id)
}
inline ::std::string* SensorMetadata::mutable_sensor_id() {
  
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.SensorMetadata.sensor_id)
  return sensor_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SensorMetadata::release_sensor_id() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.SensorMetadata.sensor_id)
  
  return sensor_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SensorMetadata::set_allocated_sensor_id(::std::string* sensor_id) {
  if (sensor_id != NULL) {
    
  } else {
    
  }
  sensor_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sensor_id);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.SensorMetadata.sensor_id)
}

// string client_id = 3;
inline void SensorMetadata::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SensorMetadata::client_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SensorMetadata.client_id)
  return client_id_.GetNoArena();
}
inline void SensorMetadata::set_client_id(const ::std::string& value) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.SensorMetadata.client_id)
}
#if LANG_CXX11
inline void SensorMetadata::set_client_id(::std::string&& value) {
  
  client_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.SensorMetadata.client_id)
}
#endif
inline void SensorMetadata::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.SensorMetadata.client_id)
}
inline void SensorMetadata::set_client_id(const char* value, size_t size) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.SensorMetadata.client_id)
}
inline ::std::string* SensorMetadata::mutable_client_id() {
  
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.SensorMetadata.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SensorMetadata::release_client_id() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.SensorMetadata.client_id)
  
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SensorMetadata::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    
  } else {
    
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.SensorMetadata.client_id)
}

// -------------------------------------------------------------------

// SensorData

// .cartographer.cloud.proto.SensorMetadata sensor_metadata = 1;
inline bool SensorData::has_sensor_metadata() const {
  return this != internal_default_instance() && sensor_metadata_ != NULL;
}
inline void SensorData::clear_sensor_metadata() {
  if (GetArenaNoVirtual() == NULL && sensor_metadata_ != NULL) {
    delete sensor_metadata_;
  }
  sensor_metadata_ = NULL;
}
inline const ::cartographer::cloud::proto::SensorMetadata& SensorData::_internal_sensor_metadata() const {
  return *sensor_metadata_;
}
inline const ::cartographer::cloud::proto::SensorMetadata& SensorData::sensor_metadata() const {
  const ::cartographer::cloud::proto::SensorMetadata* p = sensor_metadata_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SensorData.sensor_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::cloud::proto::SensorMetadata*>(
      &::cartographer::cloud::proto::_SensorMetadata_default_instance_);
}
inline ::cartographer::cloud::proto::SensorMetadata* SensorData::release_sensor_metadata() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.SensorData.sensor_metadata)
  
  ::cartographer::cloud::proto::SensorMetadata* temp = sensor_metadata_;
  sensor_metadata_ = NULL;
  return temp;
}
inline ::cartographer::cloud::proto::SensorMetadata* SensorData::mutable_sensor_metadata() {
  
  if (sensor_metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::cloud::proto::SensorMetadata>(GetArenaNoVirtual());
    sensor_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.SensorData.sensor_metadata)
  return sensor_metadata_;
}
inline void SensorData::set_allocated_sensor_metadata(::cartographer::cloud::proto::SensorMetadata* sensor_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sensor_metadata_;
  }
  if (sensor_metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sensor_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sensor_metadata, submessage_arena);
    }
    
  } else {
    
  }
  sensor_metadata_ = sensor_metadata;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.SensorData.sensor_metadata)
}

// .cartographer.sensor.proto.OdometryData odometry_data = 2;
inline bool SensorData::has_odometry_data() const {
  return sensor_data_case() == kOdometryData;
}
inline void SensorData::set_has_odometry_data() {
  _oneof_case_[0] = kOdometryData;
}
inline const ::cartographer::sensor::proto::OdometryData& SensorData::_internal_odometry_data() const {
  return *sensor_data_.odometry_data_;
}
inline ::cartographer::sensor::proto::OdometryData* SensorData::release_odometry_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.SensorData.odometry_data)
  if (has_odometry_data()) {
    clear_has_sensor_data();
      ::cartographer::sensor::proto::OdometryData* temp = sensor_data_.odometry_data_;
    sensor_data_.odometry_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cartographer::sensor::proto::OdometryData& SensorData::odometry_data() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SensorData.odometry_data)
  return has_odometry_data()
      ? *sensor_data_.odometry_data_
      : *reinterpret_cast< ::cartographer::sensor::proto::OdometryData*>(&::cartographer::sensor::proto::_OdometryData_default_instance_);
}
inline ::cartographer::sensor::proto::OdometryData* SensorData::mutable_odometry_data() {
  if (!has_odometry_data()) {
    clear_sensor_data();
    set_has_odometry_data();
    sensor_data_.odometry_data_ = CreateMaybeMessage< ::cartographer::sensor::proto::OdometryData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.SensorData.odometry_data)
  return sensor_data_.odometry_data_;
}

// .cartographer.sensor.proto.ImuData imu_data = 3;
inline bool SensorData::has_imu_data() const {
  return sensor_data_case() == kImuData;
}
inline void SensorData::set_has_imu_data() {
  _oneof_case_[0] = kImuData;
}
inline const ::cartographer::sensor::proto::ImuData& SensorData::_internal_imu_data() const {
  return *sensor_data_.imu_data_;
}
inline ::cartographer::sensor::proto::ImuData* SensorData::release_imu_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.SensorData.imu_data)
  if (has_imu_data()) {
    clear_has_sensor_data();
      ::cartographer::sensor::proto::ImuData* temp = sensor_data_.imu_data_;
    sensor_data_.imu_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cartographer::sensor::proto::ImuData& SensorData::imu_data() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SensorData.imu_data)
  return has_imu_data()
      ? *sensor_data_.imu_data_
      : *reinterpret_cast< ::cartographer::sensor::proto::ImuData*>(&::cartographer::sensor::proto::_ImuData_default_instance_);
}
inline ::cartographer::sensor::proto::ImuData* SensorData::mutable_imu_data() {
  if (!has_imu_data()) {
    clear_sensor_data();
    set_has_imu_data();
    sensor_data_.imu_data_ = CreateMaybeMessage< ::cartographer::sensor::proto::ImuData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.SensorData.imu_data)
  return sensor_data_.imu_data_;
}

// .cartographer.sensor.proto.TimedPointCloudData timed_point_cloud_data = 4;
inline bool SensorData::has_timed_point_cloud_data() const {
  return sensor_data_case() == kTimedPointCloudData;
}
inline void SensorData::set_has_timed_point_cloud_data() {
  _oneof_case_[0] = kTimedPointCloudData;
}
inline const ::cartographer::sensor::proto::TimedPointCloudData& SensorData::_internal_timed_point_cloud_data() const {
  return *sensor_data_.timed_point_cloud_data_;
}
inline ::cartographer::sensor::proto::TimedPointCloudData* SensorData::release_timed_point_cloud_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.SensorData.timed_point_cloud_data)
  if (has_timed_point_cloud_data()) {
    clear_has_sensor_data();
      ::cartographer::sensor::proto::TimedPointCloudData* temp = sensor_data_.timed_point_cloud_data_;
    sensor_data_.timed_point_cloud_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cartographer::sensor::proto::TimedPointCloudData& SensorData::timed_point_cloud_data() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SensorData.timed_point_cloud_data)
  return has_timed_point_cloud_data()
      ? *sensor_data_.timed_point_cloud_data_
      : *reinterpret_cast< ::cartographer::sensor::proto::TimedPointCloudData*>(&::cartographer::sensor::proto::_TimedPointCloudData_default_instance_);
}
inline ::cartographer::sensor::proto::TimedPointCloudData* SensorData::mutable_timed_point_cloud_data() {
  if (!has_timed_point_cloud_data()) {
    clear_sensor_data();
    set_has_timed_point_cloud_data();
    sensor_data_.timed_point_cloud_data_ = CreateMaybeMessage< ::cartographer::sensor::proto::TimedPointCloudData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.SensorData.timed_point_cloud_data)
  return sensor_data_.timed_point_cloud_data_;
}

// .cartographer.sensor.proto.FixedFramePoseData fixed_frame_pose_data = 5;
inline bool SensorData::has_fixed_frame_pose_data() const {
  return sensor_data_case() == kFixedFramePoseData;
}
inline void SensorData::set_has_fixed_frame_pose_data() {
  _oneof_case_[0] = kFixedFramePoseData;
}
inline const ::cartographer::sensor::proto::FixedFramePoseData& SensorData::_internal_fixed_frame_pose_data() const {
  return *sensor_data_.fixed_frame_pose_data_;
}
inline ::cartographer::sensor::proto::FixedFramePoseData* SensorData::release_fixed_frame_pose_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.SensorData.fixed_frame_pose_data)
  if (has_fixed_frame_pose_data()) {
    clear_has_sensor_data();
      ::cartographer::sensor::proto::FixedFramePoseData* temp = sensor_data_.fixed_frame_pose_data_;
    sensor_data_.fixed_frame_pose_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cartographer::sensor::proto::FixedFramePoseData& SensorData::fixed_frame_pose_data() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SensorData.fixed_frame_pose_data)
  return has_fixed_frame_pose_data()
      ? *sensor_data_.fixed_frame_pose_data_
      : *reinterpret_cast< ::cartographer::sensor::proto::FixedFramePoseData*>(&::cartographer::sensor::proto::_FixedFramePoseData_default_instance_);
}
inline ::cartographer::sensor::proto::FixedFramePoseData* SensorData::mutable_fixed_frame_pose_data() {
  if (!has_fixed_frame_pose_data()) {
    clear_sensor_data();
    set_has_fixed_frame_pose_data();
    sensor_data_.fixed_frame_pose_data_ = CreateMaybeMessage< ::cartographer::sensor::proto::FixedFramePoseData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.SensorData.fixed_frame_pose_data)
  return sensor_data_.fixed_frame_pose_data_;
}

// .cartographer.sensor.proto.LandmarkData landmark_data = 6;
inline bool SensorData::has_landmark_data() const {
  return sensor_data_case() == kLandmarkData;
}
inline void SensorData::set_has_landmark_data() {
  _oneof_case_[0] = kLandmarkData;
}
inline const ::cartographer::sensor::proto::LandmarkData& SensorData::_internal_landmark_data() const {
  return *sensor_data_.landmark_data_;
}
inline ::cartographer::sensor::proto::LandmarkData* SensorData::release_landmark_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.SensorData.landmark_data)
  if (has_landmark_data()) {
    clear_has_sensor_data();
      ::cartographer::sensor::proto::LandmarkData* temp = sensor_data_.landmark_data_;
    sensor_data_.landmark_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cartographer::sensor::proto::LandmarkData& SensorData::landmark_data() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SensorData.landmark_data)
  return has_landmark_data()
      ? *sensor_data_.landmark_data_
      : *reinterpret_cast< ::cartographer::sensor::proto::LandmarkData*>(&::cartographer::sensor::proto::_LandmarkData_default_instance_);
}
inline ::cartographer::sensor::proto::LandmarkData* SensorData::mutable_landmark_data() {
  if (!has_landmark_data()) {
    clear_sensor_data();
    set_has_landmark_data();
    sensor_data_.landmark_data_ = CreateMaybeMessage< ::cartographer::sensor::proto::LandmarkData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.SensorData.landmark_data)
  return sensor_data_.landmark_data_;
}

// .cartographer.mapping.proto.LocalSlamResultData local_slam_result_data = 7;
inline bool SensorData::has_local_slam_result_data() const {
  return sensor_data_case() == kLocalSlamResultData;
}
inline void SensorData::set_has_local_slam_result_data() {
  _oneof_case_[0] = kLocalSlamResultData;
}
inline const ::cartographer::mapping::proto::LocalSlamResultData& SensorData::_internal_local_slam_result_data() const {
  return *sensor_data_.local_slam_result_data_;
}
inline ::cartographer::mapping::proto::LocalSlamResultData* SensorData::release_local_slam_result_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.SensorData.local_slam_result_data)
  if (has_local_slam_result_data()) {
    clear_has_sensor_data();
      ::cartographer::mapping::proto::LocalSlamResultData* temp = sensor_data_.local_slam_result_data_;
    sensor_data_.local_slam_result_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cartographer::mapping::proto::LocalSlamResultData& SensorData::local_slam_result_data() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SensorData.local_slam_result_data)
  return has_local_slam_result_data()
      ? *sensor_data_.local_slam_result_data_
      : *reinterpret_cast< ::cartographer::mapping::proto::LocalSlamResultData*>(&::cartographer::mapping::proto::_LocalSlamResultData_default_instance_);
}
inline ::cartographer::mapping::proto::LocalSlamResultData* SensorData::mutable_local_slam_result_data() {
  if (!has_local_slam_result_data()) {
    clear_sensor_data();
    set_has_local_slam_result_data();
    sensor_data_.local_slam_result_data_ = CreateMaybeMessage< ::cartographer::mapping::proto::LocalSlamResultData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.SensorData.local_slam_result_data)
  return sensor_data_.local_slam_result_data_;
}

inline bool SensorData::has_sensor_data() const {
  return sensor_data_case() != SENSOR_DATA_NOT_SET;
}
inline void SensorData::clear_has_sensor_data() {
  _oneof_case_[0] = SENSOR_DATA_NOT_SET;
}
inline SensorData::SensorDataCase SensorData::sensor_data_case() const {
  return SensorData::SensorDataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AddTrajectoryResponse

// int32 trajectory_id = 1;
inline void AddTrajectoryResponse::clear_trajectory_id() {
  trajectory_id_ = 0;
}
inline ::google::protobuf::int32 AddTrajectoryResponse::trajectory_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddTrajectoryResponse.trajectory_id)
  return trajectory_id_;
}
inline void AddTrajectoryResponse::set_trajectory_id(::google::protobuf::int32 value) {
  
  trajectory_id_ = value;
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.AddTrajectoryResponse.trajectory_id)
}

// -------------------------------------------------------------------

// AddSensorDataBatchRequest

// repeated .cartographer.cloud.proto.SensorData sensor_data = 1;
inline int AddSensorDataBatchRequest::sensor_data_size() const {
  return sensor_data_.size();
}
inline void AddSensorDataBatchRequest::clear_sensor_data() {
  sensor_data_.Clear();
}
inline ::cartographer::cloud::proto::SensorData* AddSensorDataBatchRequest::mutable_sensor_data(int index) {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddSensorDataBatchRequest.sensor_data)
  return sensor_data_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::cartographer::cloud::proto::SensorData >*
AddSensorDataBatchRequest::mutable_sensor_data() {
  // @@protoc_insertion_point(field_mutable_list:cartographer.cloud.proto.AddSensorDataBatchRequest.sensor_data)
  return &sensor_data_;
}
inline const ::cartographer::cloud::proto::SensorData& AddSensorDataBatchRequest::sensor_data(int index) const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddSensorDataBatchRequest.sensor_data)
  return sensor_data_.Get(index);
}
inline ::cartographer::cloud::proto::SensorData* AddSensorDataBatchRequest::add_sensor_data() {
  // @@protoc_insertion_point(field_add:cartographer.cloud.proto.AddSensorDataBatchRequest.sensor_data)
  return sensor_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cartographer::cloud::proto::SensorData >&
AddSensorDataBatchRequest::sensor_data() const {
  // @@protoc_insertion_point(field_list:cartographer.cloud.proto.AddSensorDataBatchRequest.sensor_data)
  return sensor_data_;
}

// -------------------------------------------------------------------

// AddOdometryDataRequest

// .cartographer.cloud.proto.SensorMetadata sensor_metadata = 1;
inline bool AddOdometryDataRequest::has_sensor_metadata() const {
  return this != internal_default_instance() && sensor_metadata_ != NULL;
}
inline void AddOdometryDataRequest::clear_sensor_metadata() {
  if (GetArenaNoVirtual() == NULL && sensor_metadata_ != NULL) {
    delete sensor_metadata_;
  }
  sensor_metadata_ = NULL;
}
inline const ::cartographer::cloud::proto::SensorMetadata& AddOdometryDataRequest::_internal_sensor_metadata() const {
  return *sensor_metadata_;
}
inline const ::cartographer::cloud::proto::SensorMetadata& AddOdometryDataRequest::sensor_metadata() const {
  const ::cartographer::cloud::proto::SensorMetadata* p = sensor_metadata_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddOdometryDataRequest.sensor_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::cloud::proto::SensorMetadata*>(
      &::cartographer::cloud::proto::_SensorMetadata_default_instance_);
}
inline ::cartographer::cloud::proto::SensorMetadata* AddOdometryDataRequest::release_sensor_metadata() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.AddOdometryDataRequest.sensor_metadata)
  
  ::cartographer::cloud::proto::SensorMetadata* temp = sensor_metadata_;
  sensor_metadata_ = NULL;
  return temp;
}
inline ::cartographer::cloud::proto::SensorMetadata* AddOdometryDataRequest::mutable_sensor_metadata() {
  
  if (sensor_metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::cloud::proto::SensorMetadata>(GetArenaNoVirtual());
    sensor_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddOdometryDataRequest.sensor_metadata)
  return sensor_metadata_;
}
inline void AddOdometryDataRequest::set_allocated_sensor_metadata(::cartographer::cloud::proto::SensorMetadata* sensor_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sensor_metadata_;
  }
  if (sensor_metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sensor_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sensor_metadata, submessage_arena);
    }
    
  } else {
    
  }
  sensor_metadata_ = sensor_metadata;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.AddOdometryDataRequest.sensor_metadata)
}

// .cartographer.sensor.proto.OdometryData odometry_data = 2;
inline bool AddOdometryDataRequest::has_odometry_data() const {
  return this != internal_default_instance() && odometry_data_ != NULL;
}
inline const ::cartographer::sensor::proto::OdometryData& AddOdometryDataRequest::_internal_odometry_data() const {
  return *odometry_data_;
}
inline const ::cartographer::sensor::proto::OdometryData& AddOdometryDataRequest::odometry_data() const {
  const ::cartographer::sensor::proto::OdometryData* p = odometry_data_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddOdometryDataRequest.odometry_data)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::sensor::proto::OdometryData*>(
      &::cartographer::sensor::proto::_OdometryData_default_instance_);
}
inline ::cartographer::sensor::proto::OdometryData* AddOdometryDataRequest::release_odometry_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.AddOdometryDataRequest.odometry_data)
  
  ::cartographer::sensor::proto::OdometryData* temp = odometry_data_;
  odometry_data_ = NULL;
  return temp;
}
inline ::cartographer::sensor::proto::OdometryData* AddOdometryDataRequest::mutable_odometry_data() {
  
  if (odometry_data_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::sensor::proto::OdometryData>(GetArenaNoVirtual());
    odometry_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddOdometryDataRequest.odometry_data)
  return odometry_data_;
}
inline void AddOdometryDataRequest::set_allocated_odometry_data(::cartographer::sensor::proto::OdometryData* odometry_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(odometry_data_);
  }
  if (odometry_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      odometry_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, odometry_data, submessage_arena);
    }
    
  } else {
    
  }
  odometry_data_ = odometry_data;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.AddOdometryDataRequest.odometry_data)
}

// -------------------------------------------------------------------

// AddImuDataRequest

// .cartographer.cloud.proto.SensorMetadata sensor_metadata = 1;
inline bool AddImuDataRequest::has_sensor_metadata() const {
  return this != internal_default_instance() && sensor_metadata_ != NULL;
}
inline void AddImuDataRequest::clear_sensor_metadata() {
  if (GetArenaNoVirtual() == NULL && sensor_metadata_ != NULL) {
    delete sensor_metadata_;
  }
  sensor_metadata_ = NULL;
}
inline const ::cartographer::cloud::proto::SensorMetadata& AddImuDataRequest::_internal_sensor_metadata() const {
  return *sensor_metadata_;
}
inline const ::cartographer::cloud::proto::SensorMetadata& AddImuDataRequest::sensor_metadata() const {
  const ::cartographer::cloud::proto::SensorMetadata* p = sensor_metadata_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddImuDataRequest.sensor_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::cloud::proto::SensorMetadata*>(
      &::cartographer::cloud::proto::_SensorMetadata_default_instance_);
}
inline ::cartographer::cloud::proto::SensorMetadata* AddImuDataRequest::release_sensor_metadata() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.AddImuDataRequest.sensor_metadata)
  
  ::cartographer::cloud::proto::SensorMetadata* temp = sensor_metadata_;
  sensor_metadata_ = NULL;
  return temp;
}
inline ::cartographer::cloud::proto::SensorMetadata* AddImuDataRequest::mutable_sensor_metadata() {
  
  if (sensor_metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::cloud::proto::SensorMetadata>(GetArenaNoVirtual());
    sensor_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddImuDataRequest.sensor_metadata)
  return sensor_metadata_;
}
inline void AddImuDataRequest::set_allocated_sensor_metadata(::cartographer::cloud::proto::SensorMetadata* sensor_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sensor_metadata_;
  }
  if (sensor_metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sensor_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sensor_metadata, submessage_arena);
    }
    
  } else {
    
  }
  sensor_metadata_ = sensor_metadata;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.AddImuDataRequest.sensor_metadata)
}

// .cartographer.sensor.proto.ImuData imu_data = 2;
inline bool AddImuDataRequest::has_imu_data() const {
  return this != internal_default_instance() && imu_data_ != NULL;
}
inline const ::cartographer::sensor::proto::ImuData& AddImuDataRequest::_internal_imu_data() const {
  return *imu_data_;
}
inline const ::cartographer::sensor::proto::ImuData& AddImuDataRequest::imu_data() const {
  const ::cartographer::sensor::proto::ImuData* p = imu_data_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddImuDataRequest.imu_data)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::sensor::proto::ImuData*>(
      &::cartographer::sensor::proto::_ImuData_default_instance_);
}
inline ::cartographer::sensor::proto::ImuData* AddImuDataRequest::release_imu_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.AddImuDataRequest.imu_data)
  
  ::cartographer::sensor::proto::ImuData* temp = imu_data_;
  imu_data_ = NULL;
  return temp;
}
inline ::cartographer::sensor::proto::ImuData* AddImuDataRequest::mutable_imu_data() {
  
  if (imu_data_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::sensor::proto::ImuData>(GetArenaNoVirtual());
    imu_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddImuDataRequest.imu_data)
  return imu_data_;
}
inline void AddImuDataRequest::set_allocated_imu_data(::cartographer::sensor::proto::ImuData* imu_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(imu_data_);
  }
  if (imu_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      imu_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, imu_data, submessage_arena);
    }
    
  } else {
    
  }
  imu_data_ = imu_data;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.AddImuDataRequest.imu_data)
}

// -------------------------------------------------------------------

// AddRangefinderDataRequest

// .cartographer.cloud.proto.SensorMetadata sensor_metadata = 1;
inline bool AddRangefinderDataRequest::has_sensor_metadata() const {
  return this != internal_default_instance() && sensor_metadata_ != NULL;
}
inline void AddRangefinderDataRequest::clear_sensor_metadata() {
  if (GetArenaNoVirtual() == NULL && sensor_metadata_ != NULL) {
    delete sensor_metadata_;
  }
  sensor_metadata_ = NULL;
}
inline const ::cartographer::cloud::proto::SensorMetadata& AddRangefinderDataRequest::_internal_sensor_metadata() const {
  return *sensor_metadata_;
}
inline const ::cartographer::cloud::proto::SensorMetadata& AddRangefinderDataRequest::sensor_metadata() const {
  const ::cartographer::cloud::proto::SensorMetadata* p = sensor_metadata_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddRangefinderDataRequest.sensor_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::cloud::proto::SensorMetadata*>(
      &::cartographer::cloud::proto::_SensorMetadata_default_instance_);
}
inline ::cartographer::cloud::proto::SensorMetadata* AddRangefinderDataRequest::release_sensor_metadata() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.AddRangefinderDataRequest.sensor_metadata)
  
  ::cartographer::cloud::proto::SensorMetadata* temp = sensor_metadata_;
  sensor_metadata_ = NULL;
  return temp;
}
inline ::cartographer::cloud::proto::SensorMetadata* AddRangefinderDataRequest::mutable_sensor_metadata() {
  
  if (sensor_metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::cloud::proto::SensorMetadata>(GetArenaNoVirtual());
    sensor_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddRangefinderDataRequest.sensor_metadata)
  return sensor_metadata_;
}
inline void AddRangefinderDataRequest::set_allocated_sensor_metadata(::cartographer::cloud::proto::SensorMetadata* sensor_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sensor_metadata_;
  }
  if (sensor_metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sensor_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sensor_metadata, submessage_arena);
    }
    
  } else {
    
  }
  sensor_metadata_ = sensor_metadata;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.AddRangefinderDataRequest.sensor_metadata)
}

// .cartographer.sensor.proto.TimedPointCloudData timed_point_cloud_data = 2;
inline bool AddRangefinderDataRequest::has_timed_point_cloud_data() const {
  return this != internal_default_instance() && timed_point_cloud_data_ != NULL;
}
inline const ::cartographer::sensor::proto::TimedPointCloudData& AddRangefinderDataRequest::_internal_timed_point_cloud_data() const {
  return *timed_point_cloud_data_;
}
inline const ::cartographer::sensor::proto::TimedPointCloudData& AddRangefinderDataRequest::timed_point_cloud_data() const {
  const ::cartographer::sensor::proto::TimedPointCloudData* p = timed_point_cloud_data_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddRangefinderDataRequest.timed_point_cloud_data)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::sensor::proto::TimedPointCloudData*>(
      &::cartographer::sensor::proto::_TimedPointCloudData_default_instance_);
}
inline ::cartographer::sensor::proto::TimedPointCloudData* AddRangefinderDataRequest::release_timed_point_cloud_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.AddRangefinderDataRequest.timed_point_cloud_data)
  
  ::cartographer::sensor::proto::TimedPointCloudData* temp = timed_point_cloud_data_;
  timed_point_cloud_data_ = NULL;
  return temp;
}
inline ::cartographer::sensor::proto::TimedPointCloudData* AddRangefinderDataRequest::mutable_timed_point_cloud_data() {
  
  if (timed_point_cloud_data_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::sensor::proto::TimedPointCloudData>(GetArenaNoVirtual());
    timed_point_cloud_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddRangefinderDataRequest.timed_point_cloud_data)
  return timed_point_cloud_data_;
}
inline void AddRangefinderDataRequest::set_allocated_timed_point_cloud_data(::cartographer::sensor::proto::TimedPointCloudData* timed_point_cloud_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timed_point_cloud_data_);
  }
  if (timed_point_cloud_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timed_point_cloud_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timed_point_cloud_data, submessage_arena);
    }
    
  } else {
    
  }
  timed_point_cloud_data_ = timed_point_cloud_data;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.AddRangefinderDataRequest.timed_point_cloud_data)
}

// -------------------------------------------------------------------

// AddFixedFramePoseDataRequest

// .cartographer.cloud.proto.SensorMetadata sensor_metadata = 1;
inline bool AddFixedFramePoseDataRequest::has_sensor_metadata() const {
  return this != internal_default_instance() && sensor_metadata_ != NULL;
}
inline void AddFixedFramePoseDataRequest::clear_sensor_metadata() {
  if (GetArenaNoVirtual() == NULL && sensor_metadata_ != NULL) {
    delete sensor_metadata_;
  }
  sensor_metadata_ = NULL;
}
inline const ::cartographer::cloud::proto::SensorMetadata& AddFixedFramePoseDataRequest::_internal_sensor_metadata() const {
  return *sensor_metadata_;
}
inline const ::cartographer::cloud::proto::SensorMetadata& AddFixedFramePoseDataRequest::sensor_metadata() const {
  const ::cartographer::cloud::proto::SensorMetadata* p = sensor_metadata_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddFixedFramePoseDataRequest.sensor_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::cloud::proto::SensorMetadata*>(
      &::cartographer::cloud::proto::_SensorMetadata_default_instance_);
}
inline ::cartographer::cloud::proto::SensorMetadata* AddFixedFramePoseDataRequest::release_sensor_metadata() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.AddFixedFramePoseDataRequest.sensor_metadata)
  
  ::cartographer::cloud::proto::SensorMetadata* temp = sensor_metadata_;
  sensor_metadata_ = NULL;
  return temp;
}
inline ::cartographer::cloud::proto::SensorMetadata* AddFixedFramePoseDataRequest::mutable_sensor_metadata() {
  
  if (sensor_metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::cloud::proto::SensorMetadata>(GetArenaNoVirtual());
    sensor_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddFixedFramePoseDataRequest.sensor_metadata)
  return sensor_metadata_;
}
inline void AddFixedFramePoseDataRequest::set_allocated_sensor_metadata(::cartographer::cloud::proto::SensorMetadata* sensor_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sensor_metadata_;
  }
  if (sensor_metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sensor_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sensor_metadata, submessage_arena);
    }
    
  } else {
    
  }
  sensor_metadata_ = sensor_metadata;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.AddFixedFramePoseDataRequest.sensor_metadata)
}

// .cartographer.sensor.proto.FixedFramePoseData fixed_frame_pose_data = 2;
inline bool AddFixedFramePoseDataRequest::has_fixed_frame_pose_data() const {
  return this != internal_default_instance() && fixed_frame_pose_data_ != NULL;
}
inline const ::cartographer::sensor::proto::FixedFramePoseData& AddFixedFramePoseDataRequest::_internal_fixed_frame_pose_data() const {
  return *fixed_frame_pose_data_;
}
inline const ::cartographer::sensor::proto::FixedFramePoseData& AddFixedFramePoseDataRequest::fixed_frame_pose_data() const {
  const ::cartographer::sensor::proto::FixedFramePoseData* p = fixed_frame_pose_data_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddFixedFramePoseDataRequest.fixed_frame_pose_data)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::sensor::proto::FixedFramePoseData*>(
      &::cartographer::sensor::proto::_FixedFramePoseData_default_instance_);
}
inline ::cartographer::sensor::proto::FixedFramePoseData* AddFixedFramePoseDataRequest::release_fixed_frame_pose_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.AddFixedFramePoseDataRequest.fixed_frame_pose_data)
  
  ::cartographer::sensor::proto::FixedFramePoseData* temp = fixed_frame_pose_data_;
  fixed_frame_pose_data_ = NULL;
  return temp;
}
inline ::cartographer::sensor::proto::FixedFramePoseData* AddFixedFramePoseDataRequest::mutable_fixed_frame_pose_data() {
  
  if (fixed_frame_pose_data_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::sensor::proto::FixedFramePoseData>(GetArenaNoVirtual());
    fixed_frame_pose_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddFixedFramePoseDataRequest.fixed_frame_pose_data)
  return fixed_frame_pose_data_;
}
inline void AddFixedFramePoseDataRequest::set_allocated_fixed_frame_pose_data(::cartographer::sensor::proto::FixedFramePoseData* fixed_frame_pose_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(fixed_frame_pose_data_);
  }
  if (fixed_frame_pose_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      fixed_frame_pose_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fixed_frame_pose_data, submessage_arena);
    }
    
  } else {
    
  }
  fixed_frame_pose_data_ = fixed_frame_pose_data;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.AddFixedFramePoseDataRequest.fixed_frame_pose_data)
}

// -------------------------------------------------------------------

// AddLandmarkDataRequest

// .cartographer.cloud.proto.SensorMetadata sensor_metadata = 1;
inline bool AddLandmarkDataRequest::has_sensor_metadata() const {
  return this != internal_default_instance() && sensor_metadata_ != NULL;
}
inline void AddLandmarkDataRequest::clear_sensor_metadata() {
  if (GetArenaNoVirtual() == NULL && sensor_metadata_ != NULL) {
    delete sensor_metadata_;
  }
  sensor_metadata_ = NULL;
}
inline const ::cartographer::cloud::proto::SensorMetadata& AddLandmarkDataRequest::_internal_sensor_metadata() const {
  return *sensor_metadata_;
}
inline const ::cartographer::cloud::proto::SensorMetadata& AddLandmarkDataRequest::sensor_metadata() const {
  const ::cartographer::cloud::proto::SensorMetadata* p = sensor_metadata_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddLandmarkDataRequest.sensor_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::cloud::proto::SensorMetadata*>(
      &::cartographer::cloud::proto::_SensorMetadata_default_instance_);
}
inline ::cartographer::cloud::proto::SensorMetadata* AddLandmarkDataRequest::release_sensor_metadata() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.AddLandmarkDataRequest.sensor_metadata)
  
  ::cartographer::cloud::proto::SensorMetadata* temp = sensor_metadata_;
  sensor_metadata_ = NULL;
  return temp;
}
inline ::cartographer::cloud::proto::SensorMetadata* AddLandmarkDataRequest::mutable_sensor_metadata() {
  
  if (sensor_metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::cloud::proto::SensorMetadata>(GetArenaNoVirtual());
    sensor_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddLandmarkDataRequest.sensor_metadata)
  return sensor_metadata_;
}
inline void AddLandmarkDataRequest::set_allocated_sensor_metadata(::cartographer::cloud::proto::SensorMetadata* sensor_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sensor_metadata_;
  }
  if (sensor_metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sensor_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sensor_metadata, submessage_arena);
    }
    
  } else {
    
  }
  sensor_metadata_ = sensor_metadata;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.AddLandmarkDataRequest.sensor_metadata)
}

// .cartographer.sensor.proto.LandmarkData landmark_data = 2;
inline bool AddLandmarkDataRequest::has_landmark_data() const {
  return this != internal_default_instance() && landmark_data_ != NULL;
}
inline const ::cartographer::sensor::proto::LandmarkData& AddLandmarkDataRequest::_internal_landmark_data() const {
  return *landmark_data_;
}
inline const ::cartographer::sensor::proto::LandmarkData& AddLandmarkDataRequest::landmark_data() const {
  const ::cartographer::sensor::proto::LandmarkData* p = landmark_data_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddLandmarkDataRequest.landmark_data)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::sensor::proto::LandmarkData*>(
      &::cartographer::sensor::proto::_LandmarkData_default_instance_);
}
inline ::cartographer::sensor::proto::LandmarkData* AddLandmarkDataRequest::release_landmark_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.AddLandmarkDataRequest.landmark_data)
  
  ::cartographer::sensor::proto::LandmarkData* temp = landmark_data_;
  landmark_data_ = NULL;
  return temp;
}
inline ::cartographer::sensor::proto::LandmarkData* AddLandmarkDataRequest::mutable_landmark_data() {
  
  if (landmark_data_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::sensor::proto::LandmarkData>(GetArenaNoVirtual());
    landmark_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddLandmarkDataRequest.landmark_data)
  return landmark_data_;
}
inline void AddLandmarkDataRequest::set_allocated_landmark_data(::cartographer::sensor::proto::LandmarkData* landmark_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(landmark_data_);
  }
  if (landmark_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      landmark_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, landmark_data, submessage_arena);
    }
    
  } else {
    
  }
  landmark_data_ = landmark_data;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.AddLandmarkDataRequest.landmark_data)
}

// -------------------------------------------------------------------

// FinishTrajectoryRequest

// int32 trajectory_id = 1;
inline void FinishTrajectoryRequest::clear_trajectory_id() {
  trajectory_id_ = 0;
}
inline ::google::protobuf::int32 FinishTrajectoryRequest::trajectory_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.FinishTrajectoryRequest.trajectory_id)
  return trajectory_id_;
}
inline void FinishTrajectoryRequest::set_trajectory_id(::google::protobuf::int32 value) {
  
  trajectory_id_ = value;
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.FinishTrajectoryRequest.trajectory_id)
}

// string client_id = 2;
inline void FinishTrajectoryRequest::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FinishTrajectoryRequest::client_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.FinishTrajectoryRequest.client_id)
  return client_id_.GetNoArena();
}
inline void FinishTrajectoryRequest::set_client_id(const ::std::string& value) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.FinishTrajectoryRequest.client_id)
}
#if LANG_CXX11
inline void FinishTrajectoryRequest::set_client_id(::std::string&& value) {
  
  client_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.FinishTrajectoryRequest.client_id)
}
#endif
inline void FinishTrajectoryRequest::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.FinishTrajectoryRequest.client_id)
}
inline void FinishTrajectoryRequest::set_client_id(const char* value, size_t size) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.FinishTrajectoryRequest.client_id)
}
inline ::std::string* FinishTrajectoryRequest::mutable_client_id() {
  
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.FinishTrajectoryRequest.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FinishTrajectoryRequest::release_client_id() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.FinishTrajectoryRequest.client_id)
  
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FinishTrajectoryRequest::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    
  } else {
    
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.FinishTrajectoryRequest.client_id)
}

// -------------------------------------------------------------------

// DeleteTrajectoryRequest

// int32 trajectory_id = 1;
inline void DeleteTrajectoryRequest::clear_trajectory_id() {
  trajectory_id_ = 0;
}
inline ::google::protobuf::int32 DeleteTrajectoryRequest::trajectory_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.DeleteTrajectoryRequest.trajectory_id)
  return trajectory_id_;
}
inline void DeleteTrajectoryRequest::set_trajectory_id(::google::protobuf::int32 value) {
  
  trajectory_id_ = value;
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.DeleteTrajectoryRequest.trajectory_id)
}

// string client_id = 2;
inline void DeleteTrajectoryRequest::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeleteTrajectoryRequest::client_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.DeleteTrajectoryRequest.client_id)
  return client_id_.GetNoArena();
}
inline void DeleteTrajectoryRequest::set_client_id(const ::std::string& value) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.DeleteTrajectoryRequest.client_id)
}
#if LANG_CXX11
inline void DeleteTrajectoryRequest::set_client_id(::std::string&& value) {
  
  client_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.DeleteTrajectoryRequest.client_id)
}
#endif
inline void DeleteTrajectoryRequest::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.DeleteTrajectoryRequest.client_id)
}
inline void DeleteTrajectoryRequest::set_client_id(const char* value, size_t size) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.DeleteTrajectoryRequest.client_id)
}
inline ::std::string* DeleteTrajectoryRequest::mutable_client_id() {
  
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.DeleteTrajectoryRequest.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteTrajectoryRequest::release_client_id() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.DeleteTrajectoryRequest.client_id)
  
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteTrajectoryRequest::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    
  } else {
    
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.DeleteTrajectoryRequest.client_id)
}

// -------------------------------------------------------------------

// ReceiveLocalSlamResultsRequest

// int32 trajectory_id = 1;
inline void ReceiveLocalSlamResultsRequest::clear_trajectory_id() {
  trajectory_id_ = 0;
}
inline ::google::protobuf::int32 ReceiveLocalSlamResultsRequest::trajectory_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.ReceiveLocalSlamResultsRequest.trajectory_id)
  return trajectory_id_;
}
inline void ReceiveLocalSlamResultsRequest::set_trajectory_id(::google::protobuf::int32 value) {
  
  trajectory_id_ = value;
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.ReceiveLocalSlamResultsRequest.trajectory_id)
}

// -------------------------------------------------------------------

// LocalSlamInsertionResult

// .cartographer.mapping.proto.NodeId node_id = 1;
inline bool LocalSlamInsertionResult::has_node_id() const {
  return this != internal_default_instance() && node_id_ != NULL;
}
inline const ::cartographer::mapping::proto::NodeId& LocalSlamInsertionResult::_internal_node_id() const {
  return *node_id_;
}
inline const ::cartographer::mapping::proto::NodeId& LocalSlamInsertionResult::node_id() const {
  const ::cartographer::mapping::proto::NodeId* p = node_id_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.LocalSlamInsertionResult.node_id)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::mapping::proto::NodeId*>(
      &::cartographer::mapping::proto::_NodeId_default_instance_);
}
inline ::cartographer::mapping::proto::NodeId* LocalSlamInsertionResult::release_node_id() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.LocalSlamInsertionResult.node_id)
  
  ::cartographer::mapping::proto::NodeId* temp = node_id_;
  node_id_ = NULL;
  return temp;
}
inline ::cartographer::mapping::proto::NodeId* LocalSlamInsertionResult::mutable_node_id() {
  
  if (node_id_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::mapping::proto::NodeId>(GetArenaNoVirtual());
    node_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.LocalSlamInsertionResult.node_id)
  return node_id_;
}
inline void LocalSlamInsertionResult::set_allocated_node_id(::cartographer::mapping::proto::NodeId* node_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(node_id_);
  }
  if (node_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      node_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node_id, submessage_arena);
    }
    
  } else {
    
  }
  node_id_ = node_id;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.LocalSlamInsertionResult.node_id)
}

// -------------------------------------------------------------------

// ReceiveLocalSlamResultsResponse

// int32 trajectory_id = 1;
inline void ReceiveLocalSlamResultsResponse::clear_trajectory_id() {
  trajectory_id_ = 0;
}
inline ::google::protobuf::int32 ReceiveLocalSlamResultsResponse::trajectory_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.trajectory_id)
  return trajectory_id_;
}
inline void ReceiveLocalSlamResultsResponse::set_trajectory_id(::google::protobuf::int32 value) {
  
  trajectory_id_ = value;
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.trajectory_id)
}

// int64 timestamp = 2;
inline void ReceiveLocalSlamResultsResponse::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ReceiveLocalSlamResultsResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.timestamp)
  return timestamp_;
}
inline void ReceiveLocalSlamResultsResponse::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.timestamp)
}

// .cartographer.transform.proto.Rigid3d local_pose = 3;
inline bool ReceiveLocalSlamResultsResponse::has_local_pose() const {
  return this != internal_default_instance() && local_pose_ != NULL;
}
inline const ::cartographer::transform::proto::Rigid3d& ReceiveLocalSlamResultsResponse::_internal_local_pose() const {
  return *local_pose_;
}
inline const ::cartographer::transform::proto::Rigid3d& ReceiveLocalSlamResultsResponse::local_pose() const {
  const ::cartographer::transform::proto::Rigid3d* p = local_pose_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.local_pose)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::transform::proto::Rigid3d*>(
      &::cartographer::transform::proto::_Rigid3d_default_instance_);
}
inline ::cartographer::transform::proto::Rigid3d* ReceiveLocalSlamResultsResponse::release_local_pose() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.local_pose)
  
  ::cartographer::transform::proto::Rigid3d* temp = local_pose_;
  local_pose_ = NULL;
  return temp;
}
inline ::cartographer::transform::proto::Rigid3d* ReceiveLocalSlamResultsResponse::mutable_local_pose() {
  
  if (local_pose_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::transform::proto::Rigid3d>(GetArenaNoVirtual());
    local_pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.local_pose)
  return local_pose_;
}
inline void ReceiveLocalSlamResultsResponse::set_allocated_local_pose(::cartographer::transform::proto::Rigid3d* local_pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(local_pose_);
  }
  if (local_pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      local_pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, local_pose, submessage_arena);
    }
    
  } else {
    
  }
  local_pose_ = local_pose;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.local_pose)
}

// .cartographer.sensor.proto.RangeData range_data = 4;
inline bool ReceiveLocalSlamResultsResponse::has_range_data() const {
  return this != internal_default_instance() && range_data_ != NULL;
}
inline const ::cartographer::sensor::proto::RangeData& ReceiveLocalSlamResultsResponse::_internal_range_data() const {
  return *range_data_;
}
inline const ::cartographer::sensor::proto::RangeData& ReceiveLocalSlamResultsResponse::range_data() const {
  const ::cartographer::sensor::proto::RangeData* p = range_data_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.range_data)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::sensor::proto::RangeData*>(
      &::cartographer::sensor::proto::_RangeData_default_instance_);
}
inline ::cartographer::sensor::proto::RangeData* ReceiveLocalSlamResultsResponse::release_range_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.range_data)
  
  ::cartographer::sensor::proto::RangeData* temp = range_data_;
  range_data_ = NULL;
  return temp;
}
inline ::cartographer::sensor::proto::RangeData* ReceiveLocalSlamResultsResponse::mutable_range_data() {
  
  if (range_data_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::sensor::proto::RangeData>(GetArenaNoVirtual());
    range_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.range_data)
  return range_data_;
}
inline void ReceiveLocalSlamResultsResponse::set_allocated_range_data(::cartographer::sensor::proto::RangeData* range_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(range_data_);
  }
  if (range_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      range_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, range_data, submessage_arena);
    }
    
  } else {
    
  }
  range_data_ = range_data;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.range_data)
}

// .cartographer.cloud.proto.LocalSlamInsertionResult insertion_result = 5;
inline bool ReceiveLocalSlamResultsResponse::has_insertion_result() const {
  return this != internal_default_instance() && insertion_result_ != NULL;
}
inline void ReceiveLocalSlamResultsResponse::clear_insertion_result() {
  if (GetArenaNoVirtual() == NULL && insertion_result_ != NULL) {
    delete insertion_result_;
  }
  insertion_result_ = NULL;
}
inline const ::cartographer::cloud::proto::LocalSlamInsertionResult& ReceiveLocalSlamResultsResponse::_internal_insertion_result() const {
  return *insertion_result_;
}
inline const ::cartographer::cloud::proto::LocalSlamInsertionResult& ReceiveLocalSlamResultsResponse::insertion_result() const {
  const ::cartographer::cloud::proto::LocalSlamInsertionResult* p = insertion_result_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.insertion_result)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::cloud::proto::LocalSlamInsertionResult*>(
      &::cartographer::cloud::proto::_LocalSlamInsertionResult_default_instance_);
}
inline ::cartographer::cloud::proto::LocalSlamInsertionResult* ReceiveLocalSlamResultsResponse::release_insertion_result() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.insertion_result)
  
  ::cartographer::cloud::proto::LocalSlamInsertionResult* temp = insertion_result_;
  insertion_result_ = NULL;
  return temp;
}
inline ::cartographer::cloud::proto::LocalSlamInsertionResult* ReceiveLocalSlamResultsResponse::mutable_insertion_result() {
  
  if (insertion_result_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::cloud::proto::LocalSlamInsertionResult>(GetArenaNoVirtual());
    insertion_result_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.insertion_result)
  return insertion_result_;
}
inline void ReceiveLocalSlamResultsResponse::set_allocated_insertion_result(::cartographer::cloud::proto::LocalSlamInsertionResult* insertion_result) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete insertion_result_;
  }
  if (insertion_result) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      insertion_result = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, insertion_result, submessage_arena);
    }
    
  } else {
    
  }
  insertion_result_ = insertion_result;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.insertion_result)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ReceiveGlobalSlamOptimizationsResponse

// map<int32, .cartographer.mapping.proto.NodeId> last_optimized_node_ids = 1;
inline int ReceiveGlobalSlamOptimizationsResponse::last_optimized_node_ids_size() const {
  return last_optimized_node_ids_.size();
}
inline const ::google::protobuf::Map< ::google::protobuf::int32, ::cartographer::mapping::proto::NodeId >&
ReceiveGlobalSlamOptimizationsResponse::last_optimized_node_ids() const {
  // @@protoc_insertion_point(field_map:cartographer.cloud.proto.ReceiveGlobalSlamOptimizationsResponse.last_optimized_node_ids)
  return last_optimized_node_ids_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::int32, ::cartographer::mapping::proto::NodeId >*
ReceiveGlobalSlamOptimizationsResponse::mutable_last_optimized_node_ids() {
  // @@protoc_insertion_point(field_mutable_map:cartographer.cloud.proto.ReceiveGlobalSlamOptimizationsResponse.last_optimized_node_ids)
  return last_optimized_node_ids_.MutableMap();
}

// map<int32, .cartographer.mapping.proto.SubmapId> last_optimized_submap_ids = 2;
inline int ReceiveGlobalSlamOptimizationsResponse::last_optimized_submap_ids_size() const {
  return last_optimized_submap_ids_.size();
}
inline const ::google::protobuf::Map< ::google::protobuf::int32, ::cartographer::mapping::proto::SubmapId >&
ReceiveGlobalSlamOptimizationsResponse::last_optimized_submap_ids() const {
  // @@protoc_insertion_point(field_map:cartographer.cloud.proto.ReceiveGlobalSlamOptimizationsResponse.last_optimized_submap_ids)
  return last_optimized_submap_ids_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::int32, ::cartographer::mapping::proto::SubmapId >*
ReceiveGlobalSlamOptimizationsResponse::mutable_last_optimized_submap_ids() {
  // @@protoc_insertion_point(field_mutable_map:cartographer.cloud.proto.ReceiveGlobalSlamOptimizationsResponse.last_optimized_submap_ids)
  return last_optimized_submap_ids_.MutableMap();
}

// -------------------------------------------------------------------

// GetSubmapRequest

// .cartographer.mapping.proto.SubmapId submap_id = 1;
inline bool GetSubmapRequest::has_submap_id() const {
  return this != internal_default_instance() && submap_id_ != NULL;
}
inline const ::cartographer::mapping::proto::SubmapId& GetSubmapRequest::_internal_submap_id() const {
  return *submap_id_;
}
inline const ::cartographer::mapping::proto::SubmapId& GetSubmapRequest::submap_id() const {
  const ::cartographer::mapping::proto::SubmapId* p = submap_id_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.GetSubmapRequest.submap_id)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::mapping::proto::SubmapId*>(
      &::cartographer::mapping::proto::_SubmapId_default_instance_);
}
inline ::cartographer::mapping::proto::SubmapId* GetSubmapRequest::release_submap_id() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.GetSubmapRequest.submap_id)
  
  ::cartographer::mapping::proto::SubmapId* temp = submap_id_;
  submap_id_ = NULL;
  return temp;
}
inline ::cartographer::mapping::proto::SubmapId* GetSubmapRequest::mutable_submap_id() {
  
  if (submap_id_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::mapping::proto::SubmapId>(GetArenaNoVirtual());
    submap_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.GetSubmapRequest.submap_id)
  return submap_id_;
}
inline void GetSubmapRequest::set_allocated_submap_id(::cartographer::mapping::proto::SubmapId* submap_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(submap_id_);
  }
  if (submap_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      submap_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, submap_id, submessage_arena);
    }
    
  } else {
    
  }
  submap_id_ = submap_id;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.GetSubmapRequest.submap_id)
}

// -------------------------------------------------------------------

// LoadStateRequest

// .cartographer.mapping.proto.SerializedData serialized_data = 1;
inline bool LoadStateRequest::has_serialized_data() const {
  return state_chunk_case() == kSerializedData;
}
inline void LoadStateRequest::set_has_serialized_data() {
  _oneof_case_[0] = kSerializedData;
}
inline const ::cartographer::mapping::proto::SerializedData& LoadStateRequest::_internal_serialized_data() const {
  return *state_chunk_.serialized_data_;
}
inline ::cartographer::mapping::proto::SerializedData* LoadStateRequest::release_serialized_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.LoadStateRequest.serialized_data)
  if (has_serialized_data()) {
    clear_has_state_chunk();
      ::cartographer::mapping::proto::SerializedData* temp = state_chunk_.serialized_data_;
    state_chunk_.serialized_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cartographer::mapping::proto::SerializedData& LoadStateRequest::serialized_data() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.LoadStateRequest.serialized_data)
  return has_serialized_data()
      ? *state_chunk_.serialized_data_
      : *reinterpret_cast< ::cartographer::mapping::proto::SerializedData*>(&::cartographer::mapping::proto::_SerializedData_default_instance_);
}
inline ::cartographer::mapping::proto::SerializedData* LoadStateRequest::mutable_serialized_data() {
  if (!has_serialized_data()) {
    clear_state_chunk();
    set_has_serialized_data();
    state_chunk_.serialized_data_ = CreateMaybeMessage< ::cartographer::mapping::proto::SerializedData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.LoadStateRequest.serialized_data)
  return state_chunk_.serialized_data_;
}

// .cartographer.mapping.proto.SerializationHeader serialization_header = 2;
inline bool LoadStateRequest::has_serialization_header() const {
  return state_chunk_case() == kSerializationHeader;
}
inline void LoadStateRequest::set_has_serialization_header() {
  _oneof_case_[0] = kSerializationHeader;
}
inline const ::cartographer::mapping::proto::SerializationHeader& LoadStateRequest::_internal_serialization_header() const {
  return *state_chunk_.serialization_header_;
}
inline ::cartographer::mapping::proto::SerializationHeader* LoadStateRequest::release_serialization_header() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.LoadStateRequest.serialization_header)
  if (has_serialization_header()) {
    clear_has_state_chunk();
      ::cartographer::mapping::proto::SerializationHeader* temp = state_chunk_.serialization_header_;
    state_chunk_.serialization_header_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cartographer::mapping::proto::SerializationHeader& LoadStateRequest::serialization_header() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.LoadStateRequest.serialization_header)
  return has_serialization_header()
      ? *state_chunk_.serialization_header_
      : *reinterpret_cast< ::cartographer::mapping::proto::SerializationHeader*>(&::cartographer::mapping::proto::_SerializationHeader_default_instance_);
}
inline ::cartographer::mapping::proto::SerializationHeader* LoadStateRequest::mutable_serialization_header() {
  if (!has_serialization_header()) {
    clear_state_chunk();
    set_has_serialization_header();
    state_chunk_.serialization_header_ = CreateMaybeMessage< ::cartographer::mapping::proto::SerializationHeader >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.LoadStateRequest.serialization_header)
  return state_chunk_.serialization_header_;
}

// string client_id = 3;
inline bool LoadStateRequest::has_client_id() const {
  return state_chunk_case() == kClientId;
}
inline void LoadStateRequest::set_has_client_id() {
  _oneof_case_[0] = kClientId;
}
inline void LoadStateRequest::clear_client_id() {
  if (has_client_id()) {
    state_chunk_.client_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_state_chunk();
  }
}
inline const ::std::string& LoadStateRequest::client_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.LoadStateRequest.client_id)
  if (has_client_id()) {
    return state_chunk_.client_id_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void LoadStateRequest::set_client_id(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.LoadStateRequest.client_id)
  if (!has_client_id()) {
    clear_state_chunk();
    set_has_client_id();
    state_chunk_.client_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  state_chunk_.client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.LoadStateRequest.client_id)
}
#if LANG_CXX11
inline void LoadStateRequest::set_client_id(::std::string&& value) {
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.LoadStateRequest.client_id)
  if (!has_client_id()) {
    clear_state_chunk();
    set_has_client_id();
    state_chunk_.client_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  state_chunk_.client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.LoadStateRequest.client_id)
}
#endif
inline void LoadStateRequest::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_client_id()) {
    clear_state_chunk();
    set_has_client_id();
    state_chunk_.client_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  state_chunk_.client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.LoadStateRequest.client_id)
}
inline void LoadStateRequest::set_client_id(const char* value, size_t size) {
  if (!has_client_id()) {
    clear_state_chunk();
    set_has_client_id();
    state_chunk_.client_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  state_chunk_.client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.LoadStateRequest.client_id)
}
inline ::std::string* LoadStateRequest::mutable_client_id() {
  if (!has_client_id()) {
    clear_state_chunk();
    set_has_client_id();
    state_chunk_.client_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.LoadStateRequest.client_id)
  return state_chunk_.client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoadStateRequest::release_client_id() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.LoadStateRequest.client_id)
  if (has_client_id()) {
    clear_has_state_chunk();
    return state_chunk_.client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void LoadStateRequest::set_allocated_client_id(::std::string* client_id) {
  if (!has_client_id()) {
    state_chunk_.client_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_state_chunk();
  if (client_id != NULL) {
    set_has_client_id();
    state_chunk_.client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  }
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.LoadStateRequest.client_id)
}

// bool load_frozen_state = 4;
inline void LoadStateRequest::clear_load_frozen_state() {
  load_frozen_state_ = false;
}
inline bool LoadStateRequest::load_frozen_state() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.LoadStateRequest.load_frozen_state)
  return load_frozen_state_;
}
inline void LoadStateRequest::set_load_frozen_state(bool value) {
  
  load_frozen_state_ = value;
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.LoadStateRequest.load_frozen_state)
}

inline bool LoadStateRequest::has_state_chunk() const {
  return state_chunk_case() != STATE_CHUNK_NOT_SET;
}
inline void LoadStateRequest::clear_has_state_chunk() {
  _oneof_case_[0] = STATE_CHUNK_NOT_SET;
}
inline LoadStateRequest::StateChunkCase LoadStateRequest::state_chunk_case() const {
  return LoadStateRequest::StateChunkCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TrajectoryRemapping

// map<int32, int32> serialized_trajectories_to_trajectories = 1;
inline int TrajectoryRemapping::serialized_trajectories_to_trajectories_size() const {
  return serialized_trajectories_to_trajectories_.size();
}
inline void TrajectoryRemapping::clear_serialized_trajectories_to_trajectories() {
  serialized_trajectories_to_trajectories_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::int32, ::google::protobuf::int32 >&
TrajectoryRemapping::serialized_trajectories_to_trajectories() const {
  // @@protoc_insertion_point(field_map:cartographer.cloud.proto.TrajectoryRemapping.serialized_trajectories_to_trajectories)
  return serialized_trajectories_to_trajectories_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::int32, ::google::protobuf::int32 >*
TrajectoryRemapping::mutable_serialized_trajectories_to_trajectories() {
  // @@protoc_insertion_point(field_mutable_map:cartographer.cloud.proto.TrajectoryRemapping.serialized_trajectories_to_trajectories)
  return serialized_trajectories_to_trajectories_.MutableMap();
}

// -------------------------------------------------------------------

// LoadStateResponse

// .cartographer.cloud.proto.TrajectoryRemapping trajectory_remapping = 1;
inline bool LoadStateResponse::has_trajectory_remapping() const {
  return this != internal_default_instance() && trajectory_remapping_ != NULL;
}
inline void LoadStateResponse::clear_trajectory_remapping() {
  if (GetArenaNoVirtual() == NULL && trajectory_remapping_ != NULL) {
    delete trajectory_remapping_;
  }
  trajectory_remapping_ = NULL;
}
inline const ::cartographer::cloud::proto::TrajectoryRemapping& LoadStateResponse::_internal_trajectory_remapping() const {
  return *trajectory_remapping_;
}
inline const ::cartographer::cloud::proto::TrajectoryRemapping& LoadStateResponse::trajectory_remapping() const {
  const ::cartographer::cloud::proto::TrajectoryRemapping* p = trajectory_remapping_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.LoadStateResponse.trajectory_remapping)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::cloud::proto::TrajectoryRemapping*>(
      &::cartographer::cloud::proto::_TrajectoryRemapping_default_instance_);
}
inline ::cartographer::cloud::proto::TrajectoryRemapping* LoadStateResponse::release_trajectory_remapping() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.LoadStateResponse.trajectory_remapping)
  
  ::cartographer::cloud::proto::TrajectoryRemapping* temp = trajectory_remapping_;
  trajectory_remapping_ = NULL;
  return temp;
}
inline ::cartographer::cloud::proto::TrajectoryRemapping* LoadStateResponse::mutable_trajectory_remapping() {
  
  if (trajectory_remapping_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::cloud::proto::TrajectoryRemapping>(GetArenaNoVirtual());
    trajectory_remapping_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.LoadStateResponse.trajectory_remapping)
  return trajectory_remapping_;
}
inline void LoadStateResponse::set_allocated_trajectory_remapping(::cartographer::cloud::proto::TrajectoryRemapping* trajectory_remapping) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete trajectory_remapping_;
  }
  if (trajectory_remapping) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      trajectory_remapping = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trajectory_remapping, submessage_arena);
    }
    
  } else {
    
  }
  trajectory_remapping_ = trajectory_remapping;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.LoadStateResponse.trajectory_remapping)
}

// -------------------------------------------------------------------

// LoadStateFromFileRequest

// string file_path = 1;
inline void LoadStateFromFileRequest::clear_file_path() {
  file_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoadStateFromFileRequest::file_path() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.LoadStateFromFileRequest.file_path)
  return file_path_.GetNoArena();
}
inline void LoadStateFromFileRequest::set_file_path(const ::std::string& value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.LoadStateFromFileRequest.file_path)
}
#if LANG_CXX11
inline void LoadStateFromFileRequest::set_file_path(::std::string&& value) {
  
  file_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.LoadStateFromFileRequest.file_path)
}
#endif
inline void LoadStateFromFileRequest::set_file_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.LoadStateFromFileRequest.file_path)
}
inline void LoadStateFromFileRequest::set_file_path(const char* value, size_t size) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.LoadStateFromFileRequest.file_path)
}
inline ::std::string* LoadStateFromFileRequest::mutable_file_path() {
  
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.LoadStateFromFileRequest.file_path)
  return file_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoadStateFromFileRequest::release_file_path() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.LoadStateFromFileRequest.file_path)
  
  return file_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoadStateFromFileRequest::set_allocated_file_path(::std::string* file_path) {
  if (file_path != NULL) {
    
  } else {
    
  }
  file_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_path);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.LoadStateFromFileRequest.file_path)
}

// string client_id = 2;
inline void LoadStateFromFileRequest::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoadStateFromFileRequest::client_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.LoadStateFromFileRequest.client_id)
  return client_id_.GetNoArena();
}
inline void LoadStateFromFileRequest::set_client_id(const ::std::string& value) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.LoadStateFromFileRequest.client_id)
}
#if LANG_CXX11
inline void LoadStateFromFileRequest::set_client_id(::std::string&& value) {
  
  client_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.LoadStateFromFileRequest.client_id)
}
#endif
inline void LoadStateFromFileRequest::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.LoadStateFromFileRequest.client_id)
}
inline void LoadStateFromFileRequest::set_client_id(const char* value, size_t size) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.LoadStateFromFileRequest.client_id)
}
inline ::std::string* LoadStateFromFileRequest::mutable_client_id() {
  
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.LoadStateFromFileRequest.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoadStateFromFileRequest::release_client_id() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.LoadStateFromFileRequest.client_id)
  
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoadStateFromFileRequest::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    
  } else {
    
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.LoadStateFromFileRequest.client_id)
}

// bool load_frozen_state = 3;
inline void LoadStateFromFileRequest::clear_load_frozen_state() {
  load_frozen_state_ = false;
}
inline bool LoadStateFromFileRequest::load_frozen_state() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.LoadStateFromFileRequest.load_frozen_state)
  return load_frozen_state_;
}
inline void LoadStateFromFileRequest::set_load_frozen_state(bool value) {
  
  load_frozen_state_ = value;
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.LoadStateFromFileRequest.load_frozen_state)
}

// -------------------------------------------------------------------

// LoadStateFromFileResponse

// .cartographer.cloud.proto.TrajectoryRemapping trajectory_remapping = 1;
inline bool LoadStateFromFileResponse::has_trajectory_remapping() const {
  return this != internal_default_instance() && trajectory_remapping_ != NULL;
}
inline void LoadStateFromFileResponse::clear_trajectory_remapping() {
  if (GetArenaNoVirtual() == NULL && trajectory_remapping_ != NULL) {
    delete trajectory_remapping_;
  }
  trajectory_remapping_ = NULL;
}
inline const ::cartographer::cloud::proto::TrajectoryRemapping& LoadStateFromFileResponse::_internal_trajectory_remapping() const {
  return *trajectory_remapping_;
}
inline const ::cartographer::cloud::proto::TrajectoryRemapping& LoadStateFromFileResponse::trajectory_remapping() const {
  const ::cartographer::cloud::proto::TrajectoryRemapping* p = trajectory_remapping_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.LoadStateFromFileResponse.trajectory_remapping)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::cloud::proto::TrajectoryRemapping*>(
      &::cartographer::cloud::proto::_TrajectoryRemapping_default_instance_);
}
inline ::cartographer::cloud::proto::TrajectoryRemapping* LoadStateFromFileResponse::release_trajectory_remapping() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.LoadStateFromFileResponse.trajectory_remapping)
  
  ::cartographer::cloud::proto::TrajectoryRemapping* temp = trajectory_remapping_;
  trajectory_remapping_ = NULL;
  return temp;
}
inline ::cartographer::cloud::proto::TrajectoryRemapping* LoadStateFromFileResponse::mutable_trajectory_remapping() {
  
  if (trajectory_remapping_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::cloud::proto::TrajectoryRemapping>(GetArenaNoVirtual());
    trajectory_remapping_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.LoadStateFromFileResponse.trajectory_remapping)
  return trajectory_remapping_;
}
inline void LoadStateFromFileResponse::set_allocated_trajectory_remapping(::cartographer::cloud::proto::TrajectoryRemapping* trajectory_remapping) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete trajectory_remapping_;
  }
  if (trajectory_remapping) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      trajectory_remapping = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trajectory_remapping, submessage_arena);
    }
    
  } else {
    
  }
  trajectory_remapping_ = trajectory_remapping;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.LoadStateFromFileResponse.trajectory_remapping)
}

// -------------------------------------------------------------------

// GetSubmapResponse

// .cartographer.mapping.proto.SubmapQuery.Response submap_query_response = 1;
inline bool GetSubmapResponse::has_submap_query_response() const {
  return this != internal_default_instance() && submap_query_response_ != NULL;
}
inline const ::cartographer::mapping::proto::SubmapQuery_Response& GetSubmapResponse::_internal_submap_query_response() const {
  return *submap_query_response_;
}
inline const ::cartographer::mapping::proto::SubmapQuery_Response& GetSubmapResponse::submap_query_response() const {
  const ::cartographer::mapping::proto::SubmapQuery_Response* p = submap_query_response_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.GetSubmapResponse.submap_query_response)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::mapping::proto::SubmapQuery_Response*>(
      &::cartographer::mapping::proto::_SubmapQuery_Response_default_instance_);
}
inline ::cartographer::mapping::proto::SubmapQuery_Response* GetSubmapResponse::release_submap_query_response() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.GetSubmapResponse.submap_query_response)
  
  ::cartographer::mapping::proto::SubmapQuery_Response* temp = submap_query_response_;
  submap_query_response_ = NULL;
  return temp;
}
inline ::cartographer::mapping::proto::SubmapQuery_Response* GetSubmapResponse::mutable_submap_query_response() {
  
  if (submap_query_response_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::mapping::proto::SubmapQuery_Response>(GetArenaNoVirtual());
    submap_query_response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.GetSubmapResponse.submap_query_response)
  return submap_query_response_;
}
inline void GetSubmapResponse::set_allocated_submap_query_response(::cartographer::mapping::proto::SubmapQuery_Response* submap_query_response) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(submap_query_response_);
  }
  if (submap_query_response) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      submap_query_response = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, submap_query_response, submessage_arena);
    }
    
  } else {
    
  }
  submap_query_response_ = submap_query_response;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.GetSubmapResponse.submap_query_response)
}

// string error_msg = 2;
inline void GetSubmapResponse::clear_error_msg() {
  error_msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetSubmapResponse::error_msg() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.GetSubmapResponse.error_msg)
  return error_msg_.GetNoArena();
}
inline void GetSubmapResponse::set_error_msg(const ::std::string& value) {
  
  error_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.GetSubmapResponse.error_msg)
}
#if LANG_CXX11
inline void GetSubmapResponse::set_error_msg(::std::string&& value) {
  
  error_msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.GetSubmapResponse.error_msg)
}
#endif
inline void GetSubmapResponse::set_error_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.GetSubmapResponse.error_msg)
}
inline void GetSubmapResponse::set_error_msg(const char* value, size_t size) {
  
  error_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.GetSubmapResponse.error_msg)
}
inline ::std::string* GetSubmapResponse::mutable_error_msg() {
  
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.GetSubmapResponse.error_msg)
  return error_msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetSubmapResponse::release_error_msg() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.GetSubmapResponse.error_msg)
  
  return error_msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetSubmapResponse::set_allocated_error_msg(::std::string* error_msg) {
  if (error_msg != NULL) {
    
  } else {
    
  }
  error_msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_msg);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.GetSubmapResponse.error_msg)
}

// -------------------------------------------------------------------

// TrajectoryNodePose_ConstantPoseData

// int64 timestamp = 1;
inline void TrajectoryNodePose_ConstantPoseData::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TrajectoryNodePose_ConstantPoseData::timestamp() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.TrajectoryNodePose.ConstantPoseData.timestamp)
  return timestamp_;
}
inline void TrajectoryNodePose_ConstantPoseData::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.TrajectoryNodePose.ConstantPoseData.timestamp)
}

// .cartographer.transform.proto.Rigid3d local_pose = 2;
inline bool TrajectoryNodePose_ConstantPoseData::has_local_pose() const {
  return this != internal_default_instance() && local_pose_ != NULL;
}
inline const ::cartographer::transform::proto::Rigid3d& TrajectoryNodePose_ConstantPoseData::_internal_local_pose() const {
  return *local_pose_;
}
inline const ::cartographer::transform::proto::Rigid3d& TrajectoryNodePose_ConstantPoseData::local_pose() const {
  const ::cartographer::transform::proto::Rigid3d* p = local_pose_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.TrajectoryNodePose.ConstantPoseData.local_pose)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::transform::proto::Rigid3d*>(
      &::cartographer::transform::proto::_Rigid3d_default_instance_);
}
inline ::cartographer::transform::proto::Rigid3d* TrajectoryNodePose_ConstantPoseData::release_local_pose() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.TrajectoryNodePose.ConstantPoseData.local_pose)
  
  ::cartographer::transform::proto::Rigid3d* temp = local_pose_;
  local_pose_ = NULL;
  return temp;
}
inline ::cartographer::transform::proto::Rigid3d* TrajectoryNodePose_ConstantPoseData::mutable_local_pose() {
  
  if (local_pose_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::transform::proto::Rigid3d>(GetArenaNoVirtual());
    local_pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.TrajectoryNodePose.ConstantPoseData.local_pose)
  return local_pose_;
}
inline void TrajectoryNodePose_ConstantPoseData::set_allocated_local_pose(::cartographer::transform::proto::Rigid3d* local_pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(local_pose_);
  }
  if (local_pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      local_pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, local_pose, submessage_arena);
    }
    
  } else {
    
  }
  local_pose_ = local_pose;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.TrajectoryNodePose.ConstantPoseData.local_pose)
}

// -------------------------------------------------------------------

// TrajectoryNodePose

// .cartographer.mapping.proto.NodeId node_id = 1;
inline bool TrajectoryNodePose::has_node_id() const {
  return this != internal_default_instance() && node_id_ != NULL;
}
inline const ::cartographer::mapping::proto::NodeId& TrajectoryNodePose::_internal_node_id() const {
  return *node_id_;
}
inline const ::cartographer::mapping::proto::NodeId& TrajectoryNodePose::node_id() const {
  const ::cartographer::mapping::proto::NodeId* p = node_id_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.TrajectoryNodePose.node_id)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::mapping::proto::NodeId*>(
      &::cartographer::mapping::proto::_NodeId_default_instance_);
}
inline ::cartographer::mapping::proto::NodeId* TrajectoryNodePose::release_node_id() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.TrajectoryNodePose.node_id)
  
  ::cartographer::mapping::proto::NodeId* temp = node_id_;
  node_id_ = NULL;
  return temp;
}
inline ::cartographer::mapping::proto::NodeId* TrajectoryNodePose::mutable_node_id() {
  
  if (node_id_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::mapping::proto::NodeId>(GetArenaNoVirtual());
    node_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.TrajectoryNodePose.node_id)
  return node_id_;
}
inline void TrajectoryNodePose::set_allocated_node_id(::cartographer::mapping::proto::NodeId* node_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(node_id_);
  }
  if (node_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      node_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node_id, submessage_arena);
    }
    
  } else {
    
  }
  node_id_ = node_id;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.TrajectoryNodePose.node_id)
}

// .cartographer.transform.proto.Rigid3d global_pose = 2;
inline bool TrajectoryNodePose::has_global_pose() const {
  return this != internal_default_instance() && global_pose_ != NULL;
}
inline const ::cartographer::transform::proto::Rigid3d& TrajectoryNodePose::_internal_global_pose() const {
  return *global_pose_;
}
inline const ::cartographer::transform::proto::Rigid3d& TrajectoryNodePose::global_pose() const {
  const ::cartographer::transform::proto::Rigid3d* p = global_pose_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.TrajectoryNodePose.global_pose)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::transform::proto::Rigid3d*>(
      &::cartographer::transform::proto::_Rigid3d_default_instance_);
}
inline ::cartographer::transform::proto::Rigid3d* TrajectoryNodePose::release_global_pose() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.TrajectoryNodePose.global_pose)
  
  ::cartographer::transform::proto::Rigid3d* temp = global_pose_;
  global_pose_ = NULL;
  return temp;
}
inline ::cartographer::transform::proto::Rigid3d* TrajectoryNodePose::mutable_global_pose() {
  
  if (global_pose_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::transform::proto::Rigid3d>(GetArenaNoVirtual());
    global_pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.TrajectoryNodePose.global_pose)
  return global_pose_;
}
inline void TrajectoryNodePose::set_allocated_global_pose(::cartographer::transform::proto::Rigid3d* global_pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(global_pose_);
  }
  if (global_pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      global_pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, global_pose, submessage_arena);
    }
    
  } else {
    
  }
  global_pose_ = global_pose;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.TrajectoryNodePose.global_pose)
}

// .cartographer.cloud.proto.TrajectoryNodePose.ConstantPoseData constant_pose_data = 3;
inline bool TrajectoryNodePose::has_constant_pose_data() const {
  return this != internal_default_instance() && constant_pose_data_ != NULL;
}
inline void TrajectoryNodePose::clear_constant_pose_data() {
  if (GetArenaNoVirtual() == NULL && constant_pose_data_ != NULL) {
    delete constant_pose_data_;
  }
  constant_pose_data_ = NULL;
}
inline const ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData& TrajectoryNodePose::_internal_constant_pose_data() const {
  return *constant_pose_data_;
}
inline const ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData& TrajectoryNodePose::constant_pose_data() const {
  const ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData* p = constant_pose_data_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.TrajectoryNodePose.constant_pose_data)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData*>(
      &::cartographer::cloud::proto::_TrajectoryNodePose_ConstantPoseData_default_instance_);
}
inline ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData* TrajectoryNodePose::release_constant_pose_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.TrajectoryNodePose.constant_pose_data)
  
  ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData* temp = constant_pose_data_;
  constant_pose_data_ = NULL;
  return temp;
}
inline ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData* TrajectoryNodePose::mutable_constant_pose_data() {
  
  if (constant_pose_data_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData>(GetArenaNoVirtual());
    constant_pose_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.TrajectoryNodePose.constant_pose_data)
  return constant_pose_data_;
}
inline void TrajectoryNodePose::set_allocated_constant_pose_data(::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData* constant_pose_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete constant_pose_data_;
  }
  if (constant_pose_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      constant_pose_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, constant_pose_data, submessage_arena);
    }
    
  } else {
    
  }
  constant_pose_data_ = constant_pose_data;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.TrajectoryNodePose.constant_pose_data)
}

// -------------------------------------------------------------------

// GetTrajectoryNodePosesResponse

// repeated .cartographer.cloud.proto.TrajectoryNodePose node_poses = 1;
inline int GetTrajectoryNodePosesResponse::node_poses_size() const {
  return node_poses_.size();
}
inline void GetTrajectoryNodePosesResponse::clear_node_poses() {
  node_poses_.Clear();
}
inline ::cartographer::cloud::proto::TrajectoryNodePose* GetTrajectoryNodePosesResponse::mutable_node_poses(int index) {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.GetTrajectoryNodePosesResponse.node_poses)
  return node_poses_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::cartographer::cloud::proto::TrajectoryNodePose >*
GetTrajectoryNodePosesResponse::mutable_node_poses() {
  // @@protoc_insertion_point(field_mutable_list:cartographer.cloud.proto.GetTrajectoryNodePosesResponse.node_poses)
  return &node_poses_;
}
inline const ::cartographer::cloud::proto::TrajectoryNodePose& GetTrajectoryNodePosesResponse::node_poses(int index) const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.GetTrajectoryNodePosesResponse.node_poses)
  return node_poses_.Get(index);
}
inline ::cartographer::cloud::proto::TrajectoryNodePose* GetTrajectoryNodePosesResponse::add_node_poses() {
  // @@protoc_insertion_point(field_add:cartographer.cloud.proto.GetTrajectoryNodePosesResponse.node_poses)
  return node_poses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cartographer::cloud::proto::TrajectoryNodePose >&
GetTrajectoryNodePosesResponse::node_poses() const {
  // @@protoc_insertion_point(field_list:cartographer.cloud.proto.GetTrajectoryNodePosesResponse.node_poses)
  return node_poses_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetTrajectoryStatesResponse

// map<int32, .cartographer.cloud.proto.TrajectoryState> trajectories_state = 1;
inline int GetTrajectoryStatesResponse::trajectories_state_size() const {
  return trajectories_state_.size();
}
inline void GetTrajectoryStatesResponse::clear_trajectories_state() {
  trajectories_state_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::int32, ::cartographer::cloud::proto::TrajectoryState >&
GetTrajectoryStatesResponse::trajectories_state() const {
  // @@protoc_insertion_point(field_map:cartographer.cloud.proto.GetTrajectoryStatesResponse.trajectories_state)
  return trajectories_state_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::int32, ::cartographer::cloud::proto::TrajectoryState >*
GetTrajectoryStatesResponse::mutable_trajectories_state() {
  // @@protoc_insertion_point(field_mutable_map:cartographer.cloud.proto.GetTrajectoryStatesResponse.trajectories_state)
  return trajectories_state_.MutableMap();
}

// -------------------------------------------------------------------

// GetLandmarkPosesResponse

// repeated .cartographer.mapping.proto.PoseGraph.LandmarkPose landmark_poses = 1;
inline int GetLandmarkPosesResponse::landmark_poses_size() const {
  return landmark_poses_.size();
}
inline ::cartographer::mapping::proto::PoseGraph_LandmarkPose* GetLandmarkPosesResponse::mutable_landmark_poses(int index) {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.GetLandmarkPosesResponse.landmark_poses)
  return landmark_poses_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::cartographer::mapping::proto::PoseGraph_LandmarkPose >*
GetLandmarkPosesResponse::mutable_landmark_poses() {
  // @@protoc_insertion_point(field_mutable_list:cartographer.cloud.proto.GetLandmarkPosesResponse.landmark_poses)
  return &landmark_poses_;
}
inline const ::cartographer::mapping::proto::PoseGraph_LandmarkPose& GetLandmarkPosesResponse::landmark_poses(int index) const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.GetLandmarkPosesResponse.landmark_poses)
  return landmark_poses_.Get(index);
}
inline ::cartographer::mapping::proto::PoseGraph_LandmarkPose* GetLandmarkPosesResponse::add_landmark_poses() {
  // @@protoc_insertion_point(field_add:cartographer.cloud.proto.GetLandmarkPosesResponse.landmark_poses)
  return landmark_poses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cartographer::mapping::proto::PoseGraph_LandmarkPose >&
GetLandmarkPosesResponse::landmark_poses() const {
  // @@protoc_insertion_point(field_list:cartographer.cloud.proto.GetLandmarkPosesResponse.landmark_poses)
  return landmark_poses_;
}

// -------------------------------------------------------------------

// SetLandmarkPoseRequest

// .cartographer.mapping.proto.PoseGraph.LandmarkPose landmark_pose = 1;
inline bool SetLandmarkPoseRequest::has_landmark_pose() const {
  return this != internal_default_instance() && landmark_pose_ != NULL;
}
inline const ::cartographer::mapping::proto::PoseGraph_LandmarkPose& SetLandmarkPoseRequest::_internal_landmark_pose() const {
  return *landmark_pose_;
}
inline const ::cartographer::mapping::proto::PoseGraph_LandmarkPose& SetLandmarkPoseRequest::landmark_pose() const {
  const ::cartographer::mapping::proto::PoseGraph_LandmarkPose* p = landmark_pose_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SetLandmarkPoseRequest.landmark_pose)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::mapping::proto::PoseGraph_LandmarkPose*>(
      &::cartographer::mapping::proto::_PoseGraph_LandmarkPose_default_instance_);
}
inline ::cartographer::mapping::proto::PoseGraph_LandmarkPose* SetLandmarkPoseRequest::release_landmark_pose() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.SetLandmarkPoseRequest.landmark_pose)
  
  ::cartographer::mapping::proto::PoseGraph_LandmarkPose* temp = landmark_pose_;
  landmark_pose_ = NULL;
  return temp;
}
inline ::cartographer::mapping::proto::PoseGraph_LandmarkPose* SetLandmarkPoseRequest::mutable_landmark_pose() {
  
  if (landmark_pose_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::mapping::proto::PoseGraph_LandmarkPose>(GetArenaNoVirtual());
    landmark_pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.SetLandmarkPoseRequest.landmark_pose)
  return landmark_pose_;
}
inline void SetLandmarkPoseRequest::set_allocated_landmark_pose(::cartographer::mapping::proto::PoseGraph_LandmarkPose* landmark_pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(landmark_pose_);
  }
  if (landmark_pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      landmark_pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, landmark_pose, submessage_arena);
    }
    
  } else {
    
  }
  landmark_pose_ = landmark_pose;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.SetLandmarkPoseRequest.landmark_pose)
}

// -------------------------------------------------------------------

// SubmapPose

// .cartographer.mapping.proto.SubmapId submap_id = 1;
inline bool SubmapPose::has_submap_id() const {
  return this != internal_default_instance() && submap_id_ != NULL;
}
inline const ::cartographer::mapping::proto::SubmapId& SubmapPose::_internal_submap_id() const {
  return *submap_id_;
}
inline const ::cartographer::mapping::proto::SubmapId& SubmapPose::submap_id() const {
  const ::cartographer::mapping::proto::SubmapId* p = submap_id_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SubmapPose.submap_id)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::mapping::proto::SubmapId*>(
      &::cartographer::mapping::proto::_SubmapId_default_instance_);
}
inline ::cartographer::mapping::proto::SubmapId* SubmapPose::release_submap_id() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.SubmapPose.submap_id)
  
  ::cartographer::mapping::proto::SubmapId* temp = submap_id_;
  submap_id_ = NULL;
  return temp;
}
inline ::cartographer::mapping::proto::SubmapId* SubmapPose::mutable_submap_id() {
  
  if (submap_id_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::mapping::proto::SubmapId>(GetArenaNoVirtual());
    submap_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.SubmapPose.submap_id)
  return submap_id_;
}
inline void SubmapPose::set_allocated_submap_id(::cartographer::mapping::proto::SubmapId* submap_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(submap_id_);
  }
  if (submap_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      submap_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, submap_id, submessage_arena);
    }
    
  } else {
    
  }
  submap_id_ = submap_id;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.SubmapPose.submap_id)
}

// int32 submap_version = 2;
inline void SubmapPose::clear_submap_version() {
  submap_version_ = 0;
}
inline ::google::protobuf::int32 SubmapPose::submap_version() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SubmapPose.submap_version)
  return submap_version_;
}
inline void SubmapPose::set_submap_version(::google::protobuf::int32 value) {
  
  submap_version_ = value;
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.SubmapPose.submap_version)
}

// .cartographer.transform.proto.Rigid3d global_pose = 3;
inline bool SubmapPose::has_global_pose() const {
  return this != internal_default_instance() && global_pose_ != NULL;
}
inline const ::cartographer::transform::proto::Rigid3d& SubmapPose::_internal_global_pose() const {
  return *global_pose_;
}
inline const ::cartographer::transform::proto::Rigid3d& SubmapPose::global_pose() const {
  const ::cartographer::transform::proto::Rigid3d* p = global_pose_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SubmapPose.global_pose)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::transform::proto::Rigid3d*>(
      &::cartographer::transform::proto::_Rigid3d_default_instance_);
}
inline ::cartographer::transform::proto::Rigid3d* SubmapPose::release_global_pose() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.SubmapPose.global_pose)
  
  ::cartographer::transform::proto::Rigid3d* temp = global_pose_;
  global_pose_ = NULL;
  return temp;
}
inline ::cartographer::transform::proto::Rigid3d* SubmapPose::mutable_global_pose() {
  
  if (global_pose_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::transform::proto::Rigid3d>(GetArenaNoVirtual());
    global_pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.SubmapPose.global_pose)
  return global_pose_;
}
inline void SubmapPose::set_allocated_global_pose(::cartographer::transform::proto::Rigid3d* global_pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(global_pose_);
  }
  if (global_pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      global_pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, global_pose, submessage_arena);
    }
    
  } else {
    
  }
  global_pose_ = global_pose;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.SubmapPose.global_pose)
}

// -------------------------------------------------------------------

// GetAllSubmapPosesResponse

// repeated .cartographer.cloud.proto.SubmapPose submap_poses = 1;
inline int GetAllSubmapPosesResponse::submap_poses_size() const {
  return submap_poses_.size();
}
inline void GetAllSubmapPosesResponse::clear_submap_poses() {
  submap_poses_.Clear();
}
inline ::cartographer::cloud::proto::SubmapPose* GetAllSubmapPosesResponse::mutable_submap_poses(int index) {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.GetAllSubmapPosesResponse.submap_poses)
  return submap_poses_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::cartographer::cloud::proto::SubmapPose >*
GetAllSubmapPosesResponse::mutable_submap_poses() {
  // @@protoc_insertion_point(field_mutable_list:cartographer.cloud.proto.GetAllSubmapPosesResponse.submap_poses)
  return &submap_poses_;
}
inline const ::cartographer::cloud::proto::SubmapPose& GetAllSubmapPosesResponse::submap_poses(int index) const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.GetAllSubmapPosesResponse.submap_poses)
  return submap_poses_.Get(index);
}
inline ::cartographer::cloud::proto::SubmapPose* GetAllSubmapPosesResponse::add_submap_poses() {
  // @@protoc_insertion_point(field_add:cartographer.cloud.proto.GetAllSubmapPosesResponse.submap_poses)
  return submap_poses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cartographer::cloud::proto::SubmapPose >&
GetAllSubmapPosesResponse::submap_poses() const {
  // @@protoc_insertion_point(field_list:cartographer.cloud.proto.GetAllSubmapPosesResponse.submap_poses)
  return submap_poses_;
}

// -------------------------------------------------------------------

// GetLocalToGlobalTransformRequest

// int32 trajectory_id = 1;
inline void GetLocalToGlobalTransformRequest::clear_trajectory_id() {
  trajectory_id_ = 0;
}
inline ::google::protobuf::int32 GetLocalToGlobalTransformRequest::trajectory_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.GetLocalToGlobalTransformRequest.trajectory_id)
  return trajectory_id_;
}
inline void GetLocalToGlobalTransformRequest::set_trajectory_id(::google::protobuf::int32 value) {
  
  trajectory_id_ = value;
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.GetLocalToGlobalTransformRequest.trajectory_id)
}

// -------------------------------------------------------------------

// GetLocalToGlobalTransformResponse

// .cartographer.transform.proto.Rigid3d local_to_global = 1;
inline bool GetLocalToGlobalTransformResponse::has_local_to_global() const {
  return this != internal_default_instance() && local_to_global_ != NULL;
}
inline const ::cartographer::transform::proto::Rigid3d& GetLocalToGlobalTransformResponse::_internal_local_to_global() const {
  return *local_to_global_;
}
inline const ::cartographer::transform::proto::Rigid3d& GetLocalToGlobalTransformResponse::local_to_global() const {
  const ::cartographer::transform::proto::Rigid3d* p = local_to_global_;
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.GetLocalToGlobalTransformResponse.local_to_global)
  return p != NULL ? *p : *reinterpret_cast<const ::cartographer::transform::proto::Rigid3d*>(
      &::cartographer::transform::proto::_Rigid3d_default_instance_);
}
inline ::cartographer::transform::proto::Rigid3d* GetLocalToGlobalTransformResponse::release_local_to_global() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.GetLocalToGlobalTransformResponse.local_to_global)
  
  ::cartographer::transform::proto::Rigid3d* temp = local_to_global_;
  local_to_global_ = NULL;
  return temp;
}
inline ::cartographer::transform::proto::Rigid3d* GetLocalToGlobalTransformResponse::mutable_local_to_global() {
  
  if (local_to_global_ == NULL) {
    auto* p = CreateMaybeMessage<::cartographer::transform::proto::Rigid3d>(GetArenaNoVirtual());
    local_to_global_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.GetLocalToGlobalTransformResponse.local_to_global)
  return local_to_global_;
}
inline void GetLocalToGlobalTransformResponse::set_allocated_local_to_global(::cartographer::transform::proto::Rigid3d* local_to_global) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(local_to_global_);
  }
  if (local_to_global) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      local_to_global = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, local_to_global, submessage_arena);
    }
    
  } else {
    
  }
  local_to_global_ = local_to_global;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.GetLocalToGlobalTransformResponse.local_to_global)
}

// -------------------------------------------------------------------

// GetConstraintsResponse

// repeated .cartographer.mapping.proto.PoseGraph.Constraint constraints = 1;
inline int GetConstraintsResponse::constraints_size() const {
  return constraints_.size();
}
inline ::cartographer::mapping::proto::PoseGraph_Constraint* GetConstraintsResponse::mutable_constraints(int index) {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.GetConstraintsResponse.constraints)
  return constraints_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::cartographer::mapping::proto::PoseGraph_Constraint >*
GetConstraintsResponse::mutable_constraints() {
  // @@protoc_insertion_point(field_mutable_list:cartographer.cloud.proto.GetConstraintsResponse.constraints)
  return &constraints_;
}
inline const ::cartographer::mapping::proto::PoseGraph_Constraint& GetConstraintsResponse::constraints(int index) const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.GetConstraintsResponse.constraints)
  return constraints_.Get(index);
}
inline ::cartographer::mapping::proto::PoseGraph_Constraint* GetConstraintsResponse::add_constraints() {
  // @@protoc_insertion_point(field_add:cartographer.cloud.proto.GetConstraintsResponse.constraints)
  return constraints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cartographer::mapping::proto::PoseGraph_Constraint >&
GetConstraintsResponse::constraints() const {
  // @@protoc_insertion_point(field_list:cartographer.cloud.proto.GetConstraintsResponse.constraints)
  return constraints_;
}

// -------------------------------------------------------------------

// WriteStateResponse

// .cartographer.mapping.proto.SerializationHeader header = 1;
inline bool WriteStateResponse::has_header() const {
  return state_chunk_case() == kHeader;
}
inline void WriteStateResponse::set_has_header() {
  _oneof_case_[0] = kHeader;
}
inline const ::cartographer::mapping::proto::SerializationHeader& WriteStateResponse::_internal_header() const {
  return *state_chunk_.header_;
}
inline ::cartographer::mapping::proto::SerializationHeader* WriteStateResponse::release_header() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.WriteStateResponse.header)
  if (has_header()) {
    clear_has_state_chunk();
      ::cartographer::mapping::proto::SerializationHeader* temp = state_chunk_.header_;
    state_chunk_.header_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cartographer::mapping::proto::SerializationHeader& WriteStateResponse::header() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.WriteStateResponse.header)
  return has_header()
      ? *state_chunk_.header_
      : *reinterpret_cast< ::cartographer::mapping::proto::SerializationHeader*>(&::cartographer::mapping::proto::_SerializationHeader_default_instance_);
}
inline ::cartographer::mapping::proto::SerializationHeader* WriteStateResponse::mutable_header() {
  if (!has_header()) {
    clear_state_chunk();
    set_has_header();
    state_chunk_.header_ = CreateMaybeMessage< ::cartographer::mapping::proto::SerializationHeader >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.WriteStateResponse.header)
  return state_chunk_.header_;
}

// .cartographer.mapping.proto.SerializedData serialized_data = 2;
inline bool WriteStateResponse::has_serialized_data() const {
  return state_chunk_case() == kSerializedData;
}
inline void WriteStateResponse::set_has_serialized_data() {
  _oneof_case_[0] = kSerializedData;
}
inline const ::cartographer::mapping::proto::SerializedData& WriteStateResponse::_internal_serialized_data() const {
  return *state_chunk_.serialized_data_;
}
inline ::cartographer::mapping::proto::SerializedData* WriteStateResponse::release_serialized_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.WriteStateResponse.serialized_data)
  if (has_serialized_data()) {
    clear_has_state_chunk();
      ::cartographer::mapping::proto::SerializedData* temp = state_chunk_.serialized_data_;
    state_chunk_.serialized_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cartographer::mapping::proto::SerializedData& WriteStateResponse::serialized_data() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.WriteStateResponse.serialized_data)
  return has_serialized_data()
      ? *state_chunk_.serialized_data_
      : *reinterpret_cast< ::cartographer::mapping::proto::SerializedData*>(&::cartographer::mapping::proto::_SerializedData_default_instance_);
}
inline ::cartographer::mapping::proto::SerializedData* WriteStateResponse::mutable_serialized_data() {
  if (!has_serialized_data()) {
    clear_state_chunk();
    set_has_serialized_data();
    state_chunk_.serialized_data_ = CreateMaybeMessage< ::cartographer::mapping::proto::SerializedData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.WriteStateResponse.serialized_data)
  return state_chunk_.serialized_data_;
}

inline bool WriteStateResponse::has_state_chunk() const {
  return state_chunk_case() != STATE_CHUNK_NOT_SET;
}
inline void WriteStateResponse::clear_has_state_chunk() {
  _oneof_case_[0] = STATE_CHUNK_NOT_SET;
}
inline WriteStateResponse::StateChunkCase WriteStateResponse::state_chunk_case() const {
  return WriteStateResponse::StateChunkCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// WriteStateToFileRequest

// string filename = 1;
inline void WriteStateToFileRequest::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WriteStateToFileRequest::filename() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.WriteStateToFileRequest.filename)
  return filename_.GetNoArena();
}
inline void WriteStateToFileRequest::set_filename(const ::std::string& value) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.WriteStateToFileRequest.filename)
}
#if LANG_CXX11
inline void WriteStateToFileRequest::set_filename(::std::string&& value) {
  
  filename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.WriteStateToFileRequest.filename)
}
#endif
inline void WriteStateToFileRequest::set_filename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.WriteStateToFileRequest.filename)
}
inline void WriteStateToFileRequest::set_filename(const char* value, size_t size) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.WriteStateToFileRequest.filename)
}
inline ::std::string* WriteStateToFileRequest::mutable_filename() {
  
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.WriteStateToFileRequest.filename)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WriteStateToFileRequest::release_filename() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.WriteStateToFileRequest.filename)
  
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WriteStateToFileRequest::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    
  } else {
    
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.WriteStateToFileRequest.filename)
}

// -------------------------------------------------------------------

// WriteStateToFileResponse

// bool success = 1;
inline void WriteStateToFileResponse::clear_success() {
  success_ = false;
}
inline bool WriteStateToFileResponse::success() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.WriteStateToFileResponse.success)
  return success_;
}
inline void WriteStateToFileResponse::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.WriteStateToFileResponse.success)
}

// -------------------------------------------------------------------

// IsTrajectoryFinishedRequest

// int32 trajectory_id = 1;
inline void IsTrajectoryFinishedRequest::clear_trajectory_id() {
  trajectory_id_ = 0;
}
inline ::google::protobuf::int32 IsTrajectoryFinishedRequest::trajectory_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.IsTrajectoryFinishedRequest.trajectory_id)
  return trajectory_id_;
}
inline void IsTrajectoryFinishedRequest::set_trajectory_id(::google::protobuf::int32 value) {
  
  trajectory_id_ = value;
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.IsTrajectoryFinishedRequest.trajectory_id)
}

// -------------------------------------------------------------------

// IsTrajectoryFinishedResponse

// bool is_finished = 1;
inline void IsTrajectoryFinishedResponse::clear_is_finished() {
  is_finished_ = false;
}
inline bool IsTrajectoryFinishedResponse::is_finished() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.IsTrajectoryFinishedResponse.is_finished)
  return is_finished_;
}
inline void IsTrajectoryFinishedResponse::set_is_finished(bool value) {
  
  is_finished_ = value;
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.IsTrajectoryFinishedResponse.is_finished)
}

// -------------------------------------------------------------------

// IsTrajectoryFrozenRequest

// int32 trajectory_id = 1;
inline void IsTrajectoryFrozenRequest::clear_trajectory_id() {
  trajectory_id_ = 0;
}
inline ::google::protobuf::int32 IsTrajectoryFrozenRequest::trajectory_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.IsTrajectoryFrozenRequest.trajectory_id)
  return trajectory_id_;
}
inline void IsTrajectoryFrozenRequest::set_trajectory_id(::google::protobuf::int32 value) {
  
  trajectory_id_ = value;
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.IsTrajectoryFrozenRequest.trajectory_id)
}

// -------------------------------------------------------------------

// IsTrajectoryFrozenResponse

// bool is_frozen = 1;
inline void IsTrajectoryFrozenResponse::clear_is_frozen() {
  is_frozen_ = false;
}
inline bool IsTrajectoryFrozenResponse::is_frozen() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.IsTrajectoryFrozenResponse.is_frozen)
  return is_frozen_;
}
inline void IsTrajectoryFrozenResponse::set_is_frozen(bool value) {
  
  is_frozen_ = value;
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.IsTrajectoryFrozenResponse.is_frozen)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace cloud
}  // namespace cartographer

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::cartographer::cloud::proto::SensorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cartographer::cloud::proto::SensorType>() {
  return ::cartographer::cloud::proto::SensorType_descriptor();
}
template <> struct is_proto_enum< ::cartographer::cloud::proto::TrajectoryState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cartographer::cloud::proto::TrajectoryState>() {
  return ::cartographer::cloud::proto::TrajectoryState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto
